#~ require "win32console"

require File.expand_path(File.join(File.dirname(__FILE__),'spec_helper.rb'))
require File.expand_path(File.join(File.dirname(__FILE__),'..','lib','tertiary_state_machine.rb'))

#   #   #   #   

describe "Lifeline" do
  lifeline = Lifeline.new
  it 'should be possible to set lifeline to low' do
    lifeline.value = :low
    lifeline.value.should == :low 
  end
  it 'should be possible to set lifeline to high' do
    lifeline.value = :high
    lifeline.value.should == :high
  end
  it 'should be possible to set lifeline to running clock' do
    lifeline.value = :running_clock
    lifeline.value.should == :running_clock
  end
  it 'should not be possible to set lifeline to rubbish' do
    lambda { lifeline.value = :rubbish }.should raise_error('unacceptable lifeline')
  end
end



#   #   #   #   

describe "MainState" do
  main_state = MainState.new
  it 'should be possible to set mainState to initial_state' do
    main_state.state= :cold_boot_state
    main_state.state.should == :cold_boot_state
  end
  it 'should be possible to set mainState to cold_boot_state' do
    main_state.state= :cold_boot_state
    main_state.state.should == :cold_boot_state
  end
  it 'should be possible to set mainState to warm_boot_state' do
    main_state.state= :warm_boot_state
    main_state.state.should == :warm_boot_state
  end
  it 'should not be possible to set mainState to rubbish_state' do
    lambda { main_state.state = :rubbish_state }.should raise_error('unacceptable main state')
  end
end

#   #   #   #   

describe 'Key' do
  switch = Key.new
  it '.power key  should be initially released' do
    switch.power.should == :released
  end	
  
  it '.power should accept :pessed' do
    switch.power(:pressed).should == :pressed
  end	
  
  it '.power should accept :released' do
    switch.power(:released).should == :released
  end	
  
  it '.power should not accept :void' do
    lambda { switch.power(:void) }.should raise_error('unknown key action')
  end	
  
  it '.cancel key should be initially released' do
    switch.cancel.should == :released
  end	
  
  it '.cancel should accept :pressed' do
    switch.cancel(:pressed).should == :pressed
  end	
  
  it '.cancel should accept :released' do
    switch.cancel(:released).should == :released
  end	
  
  it '.cancel should not accept :void' do
    lambda { switch.cancel(:void) }.should raise_error('unknown key action')
  end	
end

#   #   #   #   

describe "StateMachines" do
  sm = StateMachines.new

  it 'should include state method' do
    sm.methods.should include('state')
  end	
  it 'should include lifeline? method' do
    sm.methods.should include('lifeline?')
  end	

  it 'should be initialised to :cold_start' do
    sm.state.should == :cold_start
  end	

  it 'should be able to set lifeline? bit to :factory_build' do
    sm.lifeline?(:factory_build).should == :factory_build
  end	
  
  it 'should be able to set lifeline? bit to :final_build' do
    sm.lifeline?(:factory_build).should == :factory_build
  end	
  
  it 'should cause exception if lifeline not final or factory state' do
    lambda { sm.lifeline?(:void) }.should raise_error('impossible_lifeline_state')
  end	
  
  it '.lifeline? should initially be :factory_build' do
    sm.lifeline?.should == :factory_build
  end	
  
end

#   #   #   #   

describe "Typical Process" do
  t = Tertiary.new
  it 'should wake on cancel key press' do
    t.key.power :pressed
    t.power.state.should == :cold_start
  end
end

describe "StatusLines" do
  status_lines = StatusLines.new
  it 'should be possible for status lines to be :off_status'do
    status_lines.set_by_unit(:off_status)
  end
  it 'should be possible for status lines to be :production_status'do
    status_lines.set_by_unit(:production_status)
  end
  it 'should be possible for status lines to be :pre_off_2_status'do
    status_lines.set_by_unit(:pre_off_2_status)
  end
  it 'should be possible for status lines to be :pre_off_1_status'do
    status_lines.set_by_unit(:pre_off_1_status)
  end
  it 'should be possible for status lines to be :run_status'do
    status_lines.set_by_unit(:run_status)
  end
  it 'should not be possible for status lines to be :any_status'do
    lambda { status_lines.set_by_unit(:any_status) }.should raise_error('illegal status')
  end
  
end

#   #   #   #   

describe "PowerState" do
  power = PowerState.new
  it "should initially be cold_start" do
    power.state.should == :cold_start
  end
  it "should be settable to :sleeping" do
    power.state = :sleeping
    power.state. should == :sleeping
  end
  it "should be settable to :off_no_vbak" do
    power.state = :off_no_vbak
    power.state.should == :off_no_vbak
  end
  it "should cause exception if set to :partying" do
    lambda { power.state = :partying }.should raise_error('illegal power state')
  end
end

#   #   #   #   

describe "Tertiary" do
  t = Tertiary.new
	it 'unit power should be off' do
		t.unit_vbat.should == :off
	end
	t.status_lines.set_by_unit(:off_status)
	it 'should ensure statuslines are currently off_status' do
		t.status_lines.value.should == :off_status
	end
  it 'should initially set lifeline value to low' do
    t.lifeline.value.should == :low
  end
  it 'should initially set main_state to initial_state' do
    t.lifeline.value.should == :low
  end
  it 'should ensure power key is initially released' do
    t.key.power.should == :released
  end
  it 'should initialise resources'do
    t.resources == :initialised 
  end
  it 'should now sleep until key input detected' do
    t.power.state = :sleeping
    t.power.state.should == :sleeping
  end
  it 'should now sleep until key input detected' do
    t.power.state = :sleeping
    t.power.state.should == :sleeping
  end
  it 'should wake on cancel key press' do
    t.key.cancel :pressed
    t.power.state.should == :sleeping
  end
  it 'should wake on power key press' do
    t.key.power :pressed
    t.power.state.should == :sleeping
  end

  t.key.cancel :pressed
  if t.power.state == :sleeping
    it 'if cancel key and sleeping, should silence tertiary alarm on cancel key press and sleep' do
      t.tertiary_alarm.state = :off
      t.tertiary_alarm.state.should == :off
      t.power.state.should == :sleeping
			t.key.cancel :released
			t.key.cancel.should == :released
    end
  end	
	it 'should change power state to warm start if power pressed and sleeping' do
		t.key.power :pressed
		t.power.state.should == :sleeping
		t.power.state = :warm_start
		t.power.state.should == :warm_start
	end
	it 'should ensure status_lines are currently off_status or factory status' do
		t.status_lines.value.should == :off_status
	end
	it 'should sound tertiary alarm if status_lines are not off_status' do
		t.status_lines.value.should == :off_status
	end
	
	it 'should set and verify lifeline high' do
		t.lifeline.value = :high
		t.lifeline.value.should == :high
	end
	
	it 'should turn on unit power and verify' do
		t.unit_vbat = :on
		t.unit_vbat.should == :on
	end
	
	it 'should wait 5 seconds' do
		t.delay.set(5)
		t.delay.read.should == 5
	end

	t.delay.set(0)
	
	it 'status bits should not read off_status'
end







#~ :run_status, , :pre_off_2_status, :pre_off_1_status, :off_status






