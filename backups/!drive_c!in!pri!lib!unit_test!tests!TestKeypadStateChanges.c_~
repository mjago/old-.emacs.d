
#include "../src/unity.h"

#include "../../lib/base/countdown.h"
#include "../../lib/base/defs.h"
#include "../../lib/tft/defs_tft.h"
#include "../../lib/debug/defs_debug.h"
#include "../../lib/common/hardware.h"
#include "../../lib/tft/hardware_tft.h"
#include "../../lib/unit_test/hardware_unit_test.h"
#include "../../lib/base/global_vars.h"
#include "../../lib/base/menuControl.h"
#include "../../lib/base/systemAlarm.h"
#include "../../lib/base/system.h"
#include "../../lib/base/stateMachineRoutines.h"
#include "../../lib/base/validateState.h"
#include "../../lib/common/keyboard.h"
#include "../../lib/common/tones.h"
#include "../../lib/base/cfr.h"
#include "../../lib/common/crc.h"
#include "../../lib/base/flash.h"
#include "../../lib/base/menu.h"
#include "../../lib/common/conversion.h"
#include "../../lib/base/setRate.h"
#include "../../lib/base/lcdconfirm.h"
#include "../../lib/base/flowCheck.h"
#include "../../lib/base/adc.h"
#include "../../lib/common/delays.h"
#include "../../lib/base/alarms.h"
#include "../../lib/common/backlight.h"
#include "../../lib/base/bolus.h"
#include "../../lib/base/calculations.h"
#include "../../lib/base/checkServiceHours.h"
#include "../../lib/common/check_fsr.h"
#include "../../lib/common/check_status.h"
#include "../../lib/common/check_timers.h"
#include "../../lib/base/config.h"
#include "../../lib/common/syringeData.h"
#include "../../lib/base/countdown.h"
#include "../../lib/base/infusion.h"
#include "../../lib/base/initialise.h"
#include "../../lib/base/interruptRoutines.h"
#include "../../lib/base/interrupts.h"
#include "../../lib/base/eoi.h"
#include "../../lib/base/neoi.h"
#include "../../lib/base/kvo.h"
#include "../../lib/base/logging.h"
#include "../../lib/base/occlusion.h"
#include "../../lib/base/power.h"
#include "../../lib/common/rtc.h"
#include "../../lib/base/serial.h"
#include "../../lib/base/startup.h"
#include "../../lib/base/syringe.h"
#include "../../lib/base/technician.h"
#include "../../lib/base/tests.h"
#include "../../lib/base/calculations.h"
#include "../../lib/base/timers.h"
#include "../../lib/common/initRegisters.h"
#include "../../lib/base/main.h"
#include "../../lib/base/stackChecks.h"
#include "../../lib/base/graphics.h"
#include "../../lib/tft/graphics_tft.h"
#include "../../lib/base/version.h"
#include "../../lib/unit_test/display_unit_test.h"

#define NUMBER_OF_KEYS 6 // including NO_KEYS
//#define uTest(KEYPAD, STATE)	test_##KEYPAD##_test(void)
//#define VOID void

//uTest(left_key,new_infusion_input_state);
//uTest( right_key , new_infusion_input_state );

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void setTestValues(uchar state_timer, uchar main_state, uchar key_value, uchar from_state)
{
  vStateBufPtr = 0;
  change_infusion_ready_state_to (FAST_TRACK_STATE);
	sysAlarmRef = NO_SYSTEM_ALARM_ERROR;
	putFlowValue(FLOW_SERVICE_MENUS);
  initValidateState(from_state);
	change_main_state_to(main_state);
	stateTimer = state_timer;
	keyValue = key_value;
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

uchar fetchKey(uchar keyNumber)
{
	switch(keyNumber)
	{
		case 0:
			return KEY_LEFT;
		case 1:
			return KEY_RIGHT;
		case 2:
			return KEY_UP;
		case 3:
			return KEY_DOWN;
		case 4:
			return KEY_ENTER;
		case 5:
			return NO_KEYS;
		default:
			TEST_ASSERT_EQUAL_HEX8(FALSE,TRUE);
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

	void setUp(void)
{
	putKeyChange(TRUE);
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void tearDown(void)
{
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_NULL_MAIN_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,NULL_MAIN_STATE,fetchKey(count),NULL_MAIN_STATE);
    change_infusion_ready_state_to (RATE_UNSET_UNLOADED);
		putKeyChange(TRUE); // (setup keypress)
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(INVALID_MAIN_STATE, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(NULL_MAIN_STATE, _c_mainState);					// Check for no state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_ALARM_DISPLAY_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,ALARM_DISPLAY_STATE,fetchKey(count),START_STATE);
    	change_infusion_ready_state_to (FAST_TRACK_STATE);
		_c_alarmState = NO_ALARM_STATE;
		putKeyChange(TRUE); // (setup keypress)
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(ALARM_INPUT_STATE, _c_mainState);	// Check for correct state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_LEFT_KEY_input_for_ALARM_INPUT_STATE(void)
{
	setTestValues(0,ALARM_INPUT_STATE,KEY_LEFT,ALARM_DISPLAY_STATE);
	serviceMenus();
	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(ALARM_INPUT_STATE, _c_mainState);							// Check state hasn't changed
	TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_RIGHT_KEY_input_for_ALARM_INPUT_STATE(void)
{
	setTestValues(0,ALARM_INPUT_STATE,KEY_RIGHT,ALARM_DISPLAY_STATE);
	change_alarm_state_to(BAT_DISCHARGED_ALARM_STATE);													// determines state transition
		serviceMenus();
	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(SHUTDOWN_STATE, _c_mainState);									// Check state transition
	TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange

	setTestValues(0,ALARM_INPUT_STATE,KEY_RIGHT,ALARM_DISPLAY_STATE);
	putKeyChange(TRUE); 																																					// (setup keypress)
	change_motor_state_to(STOPPED_STATE);
	change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
	change_alarm_state_to(SYRINGE_EMPTY_ALARM_STATE);													// determines state transition
	_c_warningState = NO_WARNING_ACTIVE_STATE;
	serviceMenus();
	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);		// Check state transition
	TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
	TEST_ASSERT_EQUAL_HEX8(NO_ALARM_STATE,_c_alarmState);									// Check alarm state has been cleared
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_UP_DOWN_ENTER_NO_KEY_input_for_ALARM_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		switch(testKey)
		{
			case KEY_UP:
			case KEY_DOWN:
			case KEY_ENTER:
				setTestValues(0,ALARM_INPUT_STATE,testKey,ALARM_DISPLAY_STATE);
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(ALARM_INPUT_STATE, _c_mainState);							// Check no state transition
				TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
				break;
			case KEY_LEFT:
			case KEY_RIGHT:
			case NO_KEYS:
				break;
			default:
				TEST_ASSERT_EQUAL_HEX8(FALSE,TRUE);
		}
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_WARNING_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,WARNING_STATE,fetchKey(count),START_STATE);
		putKeyChange(TRUE); // (setup keypress)
		change_warning_state_to(EOI_WARNING_ACTIVE_STATE);													// determines state transition
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(EOI_DISPLAY_STATE, _c_mainState);								// Check for correct state transition
		TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange

		setTestValues(0,WARNING_STATE,fetchKey(count),START_STATE);
		putKeyChange(TRUE); // (setup keypress)
		change_warning_state_to(NEOI_WARNING_ACTIVE_STATE);												// determines state transition
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(NEOI_DISPLAY_STATE, _c_mainState);							// Check for correct state transition
		TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange

		setTestValues(0,WARNING_STATE,fetchKey(count),START_STATE);
		putKeyChange(TRUE); // (setup keypress)
		change_warning_state_to(SERVICE_WARNING_ACTIVE_STATE);										// determines state transition
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(SERVICE_WARNING_DISPLAY_STATE, _c_mainState);	// Check for correct state transition
		TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange

		setTestValues(0,WARNING_STATE,fetchKey(count),START_STATE);
		putKeyChange(TRUE); 																																					// (setup keypress)
		change_warning_state_to(0xFF);																														// determines state transition
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(UNEXPECTED_WARNING_STATE, sysAlarmRef);		// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange

	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_START_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,START_STATE,fetchKey(count),START_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(START_STATE, _c_mainState);												// Check for no state transition

		setTestValues(2,START_STATE,fetchKey(count),START_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(NEW_INFUSION_DISPLAY_STATE, _c_mainState);		// Check for correct state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

		#define TEST_SYRINGE_UNCHANGED
		#define TEST_CHECK_RESUME_FLAG_TRUE
		#define TEST_CHECKPOSITIONAGAINSTRESUMEDATA_TRUE

void test_ALL_KEY_input_for_NEW_INFUSION_DISPLAY_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		rawCarriage  = 0x0;
		resume_carriage_pos = 0x124;

		setTestValues(0,NEW_INFUSION_DISPLAY_STATE,fetchKey(count),START_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(CLEAR_VALUES_DISPLAY_STATE, _c_mainState);	// Check for correct state transition

		rawCarriage  = 0x123;
		resume_carriage_pos = 0x124;

		setTestValues(0,NEW_INFUSION_DISPLAY_STATE,fetchKey(count),START_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(NEW_INFUSION_INPUT_STATE, _c_mainState);	// Check for correct state transition
//		TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																				// Check for reset keyChange

	}
}


//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

/** In uTest( left_key_input , new_infusion_input_state ) test that left key input changes state to CHECK_XY_PAD_STATE.
  * This simulates saying YES to infusion continuation.
  */

void test_LEFT_KEY_input_for_NEW_INFUSION_INPUT_STATE(void)
{
  setTestValues(0, NEW_INFUSION_INPUT_STATE,KEY_LEFT,NEW_INFUSION_DISPLAY_STATE);
  serviceMenus();
  TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
  TEST_ASSERT_EQUAL_HEX8(CHECK_XY_PAD_STATE, _c_mainState);					// Check for correct state transition
  TEST_ASSERT_EQUAL_HEX8(POWER_CYCLE_RESUME_STATE,_c_infusionReadyState); // Check correct infusion ready state transition
  TEST_ASSERT_EQUAL_HEX8(PAUSED_STATE,_c_runState); 								// Check correct run state transition
  TEST_ASSERT_EQUAL_HEX8(LOG_RESUME_FROM_POWER_ON,logName); 				// Check correct log written
  TEST_ASSERT_EQUAL_HEX8(0x1F,keyValue);														// Check for reset keyValue
  TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());											// Check for reset keyChange
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

/** In uTest( right_key_input , new_infusion_input_state ) test that right key input changes state to CLEAR_VALUES_DISPLAY_STATE.
  * This simulates saying NO to infusion continuation.
  */

//uTest( right_key , new_infusion_input_state )
void test_RIGHT_KEY_input_for_NEW_INFUSION_INPUT_STATE(void)
{
  setTestValues(0, NEW_INFUSION_INPUT_STATE,KEY_RIGHT,NEW_INFUSION_DISPLAY_STATE);
  serviceMenus();
  TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
  TEST_ASSERT_EQUAL_HEX8(CLEAR_VALUES_DISPLAY_STATE, _c_mainState);	// Check for correct state transition
  TEST_ASSERT_EQUAL_HEX8(0x1F,keyValue);														// Check for reset keyValue
  TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());											// Check for reset keyChange
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

/** In NEW_INFUSION_INPUT_STATE test that up down and enter key inputs change mainState and infusionReadyState correctly
  */

//uTest( up_down_enter , new_infusion_input_state )
void test_UP_DOWN_ENTER_KEY_input_for_NEW_INFUSION_INPUT_STATE(void)
{
	uchar count;
	uchar temp_key;
	_c_warningState = NO_WARNING_ACTIVE_STATE;
	for(count = 0; count < 6; count++)
	{
		putKeyChange(TRUE); // (setup keypress)
		switch(count)
		{
			case 0:
			case 3:
				temp_key = KEY_UP;
			  break;
			case 1:
			case 4:
				temp_key = KEY_DOWN;
			  break;
			case 2:
			case 5:
				temp_key = KEY_ENTER;
			  break;
			default:
				TEST_ASSERT_EQUAL_HEX8(FALSE,TRUE);
		}

		if(count >= 3)
		{
			change_infusion_ready_state_to(FAST_TRACK_STATE);
		}
		setTestValues(0, NEW_INFUSION_INPUT_STATE,temp_key,NEW_INFUSION_INPUT_STATE);
		change_motor_state_to(OFF_STATE);
		change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
  	serviceMenus();

  	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
  	TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);		// Check for correct state transition
  	TEST_ASSERT_EQUAL_HEX8(0x1F,keyValue);														// Check for reset keyValue
  	TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());											// Check for reset keyChange

		if(count >= 3)
		{
			TEST_ASSERT_EQUAL_HEX8(RATE_UNSET_UNLOADED,_c_infusionReadyState);	// Check infusionReadyState where it is initially FAST_TRACK_STATE
		}

	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

/** In test_no_key_input_for_new_infusion_input_state test that no key input doesn't change mainState or infusionReadyState (ie re-entrant).
  */

void test_NO_KEY_input_for_NEW_INFUSION_INPUT_STATE(void)
{
	uchar count;
	uchar temp_key;

	setTestValues(0, NEW_INFUSION_INPUT_STATE,NO_KEYS,NEW_INFUSION_DISPLAY_STATE);
	change_motor_state_to(OFF_STATE);
	change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
  serviceMenus();

	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);					// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(NEW_INFUSION_INPUT_STATE, _c_mainState);		// Check for no state transition
	TEST_ASSERT_EQUAL_HEX8(0x1F,keyValue);																							// Check for reset keyValue

	setTestValues(0, NEW_INFUSION_INPUT_STATE,NO_KEYS,NEW_INFUSION_DISPLAY_STATE);
	change_motor_state_to(OFF_STATE);
	change_infusion_ready_state_to(FAST_TRACK_STATE);
	serviceMenus();

	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);					// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(NEW_INFUSION_INPUT_STATE, _c_mainState);		// Check for no state transition
	TEST_ASSERT_EQUAL_HEX8(0x1F,keyValue);																							// Check for reset keyValue
	TEST_ASSERT_EQUAL_HEX8(FAST_TRACK_STATE,_c_infusionReadyState);			// Check infusionReadyState unchanged
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CLEAR_VALUES_DISPLAY_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,CLEAR_VALUES_DISPLAY_STATE,fetchKey(count),NEW_INFUSION_INPUT_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(CLEAR_VALUES_INPUT_STATE, _c_mainState);  // Check for correct state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_LEFT_KEY_input_for_CLEAR_VALUES_INPUT_STATE(void)
{
  setTestValues(0, CLEAR_VALUES_INPUT_STATE,KEY_LEFT,CLEAR_VALUES_DISPLAY_STATE);
  serviceMenus();
  TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
  TEST_ASSERT_EQUAL_HEX8(INSERT_CORRECT_SYRINGE_DISPLAY_STATE, _c_mainState);		// Check for correct state transition
  TEST_ASSERT_EQUAL_HEX8(0x1F,keyValue);														// Check for reset keyValue
  TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());											// Check for reset keyChange
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_RIGHT_KEY_input_for_CLEAR_VALUES_INPUT_STATE(void)
{
  setTestValues(0, CLEAR_VALUES_INPUT_STATE,KEY_RIGHT,CLEAR_VALUES_DISPLAY_STATE);
  serviceMenus();
  TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
  TEST_ASSERT_EQUAL_HEX8(CLEARING_VALUES_DISPLAY_STATE, _c_mainState);		// Check for correct state transition
  TEST_ASSERT_EQUAL_HEX8(0x1F,keyValue);														// Check for reset keyValue
  TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());											// Check for reset keyChange
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_UP_DOWN_ENTER_NO_KEY_input_for_CLEAR_VALUES_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		switch(testKey)
		{
			case KEY_UP:
			case KEY_DOWN:
			case KEY_ENTER:
				setTestValues(0,CLEAR_VALUES_INPUT_STATE,testKey,CLEAR_VALUES_DISPLAY_STATE);
				putKeyChange(TRUE); 																																					// setup keypress
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);		// Check correct state transition
				TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
				break;
			case NO_KEYS:
				setTestValues(0,CLEAR_VALUES_INPUT_STATE,testKey,CLEAR_VALUES_DISPLAY_STATE);
				putKeyChange(TRUE); 																																					// setup keypress
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(CLEAR_VALUES_INPUT_STATE, _c_mainState);	// Check no state transition

				setTestValues(MENU_TIMEOUT + 1,CLEAR_VALUES_INPUT_STATE,testKey,CLEAR_VALUES_DISPLAY_STATE);
				putKeyChange(TRUE); 																																					// setup keypress
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);		// Check correct state transition
				break;
			case KEY_LEFT:
			case KEY_RIGHT:
				break;
			default:
				TEST_ASSERT_EQUAL_HEX8(FALSE,TRUE);
		}
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CLEARING_VALUES_DISPLAY_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,CLEARING_VALUES_DISPLAY_STATE,fetchKey(count),CLEAR_VALUES_INPUT_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(CLEARING_VALUES_WAIT_STATE, _c_mainState);  // Check for correct state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_LEFT_KEY_input_for_CLEARING_VALUES_WAIT_STATE(void)
{
  setTestValues(0, CLEARING_VALUES_WAIT_STATE,KEY_LEFT,CLEARING_VALUES_DISPLAY_STATE);
  serviceMenus();
  TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
  TEST_ASSERT_EQUAL_HEX8(INSERT_CORRECT_SYRINGE_DISPLAY_STATE, _c_mainState);		// Check for correct state transition
  TEST_ASSERT_EQUAL_HEX8(0x1F,keyValue);																						// Check for reset keyValue
  TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_RIGHT_UP_DOWN_ENTER_NO_KEY_input_for_CLEARING_VALUES_WAIT_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		switch(testKey)
		{
			case KEY_RIGHT:
			case KEY_UP:
			case KEY_DOWN:
			case KEY_ENTER:
				setTestValues(0,CLEARING_VALUES_WAIT_STATE,testKey,CLEARING_VALUES_DISPLAY_STATE);
				putKeyChange(TRUE); 																																					// setup keypress
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(CLEARING_VALUES_WAIT_STATE, _c_mainState);		// Check no state transition
				TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
				break;

			case NO_KEYS:
				setTestValues(0,CLEARING_VALUES_WAIT_STATE,testKey,CLEARING_VALUES_DISPLAY_STATE);
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(CLEARING_VALUES_WAIT_STATE, _c_mainState);	// Check no state transition

				setTestValues(TWO_SEC_TIMEOUT + 1,CLEARING_VALUES_WAIT_STATE,testKey,CLEARING_VALUES_DISPLAY_STATE);
				putKeyChange(TRUE); 																																					// setup keypress
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(INSERT_CORRECT_SYRINGE_DISPLAY_STATE, _c_mainState);		// Check correct state transition
				break;
			case KEY_LEFT:
				break;
			default:
				TEST_ASSERT_EQUAL_HEX8(FALSE,TRUE);
		}
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_INSERT_CORRECT_SYRINGE_DISPLAY_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,INSERT_CORRECT_SYRINGE_DISPLAY_STATE,fetchKey(count),CLEARING_VALUES_WAIT_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(INSERT_CORRECT_SYRINGE_INPUT_STATE, _c_mainState);  // Check for correct state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_UP_DOWN_ENTER_KEY_input_for_INSERT_CORRECT_SYRINGE_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		switch(testKey)
		{
			case KEY_UP:
			case KEY_DOWN:
			case KEY_ENTER:
				setTestValues(0,INSERT_CORRECT_SYRINGE_INPUT_STATE,testKey,INSERT_CORRECT_SYRINGE_DISPLAY_STATE);
				putKeyChange(TRUE); 																																					// setup keypress
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);		// Check correct state transition
				TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
				break;

			case NO_KEYS:
			case KEY_RIGHT:
			case KEY_LEFT:
				break;
			default:
				TEST_ASSERT_EQUAL_HEX8(FALSE,TRUE);
		}
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_LEFT_RIGHT_NO_KEY_input_for_INSERT_CORRECT_SYRINGE_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		switch(testKey)
		{
			case NO_KEYS:
			case KEY_RIGHT:
			case KEY_LEFT:
				test_syringePossiblematch_return_value = FALSE;
				setTestValues(0,INSERT_CORRECT_SYRINGE_INPUT_STATE,testKey,INSERT_CORRECT_SYRINGE_DISPLAY_STATE);
				putKeyChange(TRUE); 																																					// setup keypress
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(UNRECOGNISED_SYRINGE_DISPLAY_STATE, _c_mainState);		// Check correct state transition
				if(testKey != NO_KEYS)
				{
					TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
				}

				test_syringePossiblematch_return_value = TRUE;
				setTestValues(0,INSERT_CORRECT_SYRINGE_INPUT_STATE,testKey,INSERT_CORRECT_SYRINGE_DISPLAY_STATE);
				putKeyChange(TRUE); 																																					// setup keypress
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(SELECT_SYRINGE_DISPLAY_STATE, _c_mainState);		// Check correct state transition
				if(testKey != NO_KEYS)
				{
					TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
				}


				break;
			case KEY_UP:
			case KEY_DOWN:
			case KEY_ENTER:
				break;
			default:
				TEST_ASSERT_EQUAL_HEX8(FALSE,TRUE);
		}
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SELECT_SYRINGE_DISPLAY_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,SELECT_SYRINGE_DISPLAY_STATE,fetchKey(count),INSERT_CORRECT_SYRINGE_INPUT_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(SELECT_SYRINGE_INPUT_STATE, _c_mainState);  // Check for correct state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_UP_DOWN_ENTER_KEY_input_for_SELECT_SYRINGE_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		switch(testKey)
		{
			case KEY_UP:
			case KEY_DOWN:
			case KEY_ENTER:
				setTestValues(0,SELECT_SYRINGE_INPUT_STATE,testKey,SELECT_SYRINGE_DISPLAY_STATE);
				putKeyChange(TRUE); 																																					// setup keypress
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);		// Check correct state transition
				TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
				break;
			case KEY_LEFT:
			case KEY_RIGHT:
			case NO_KEYS:
				break;
			default:
				TEST_ASSERT_EQUAL_HEX8(FALSE,TRUE);
		}
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_LEFT_KEY_input_for_SELECT_SYRINGE_INPUT_STATE(void)
{
	setTestValues(0,SELECT_SYRINGE_INPUT_STATE,KEY_LEFT,SELECT_SYRINGE_DISPLAY_STATE);
	serviceMenus();
	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(INSERT_CORRECT_SYRINGE_INPUT_STATE, _c_mainState);		// Check correct state transition
	TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_RIGHT_KEY_input_for_SELECT_SYRINGE_INPUT_STATE(void)
{
	setTestValues(0,SELECT_SYRINGE_INPUT_STATE,KEY_RIGHT,SELECT_SYRINGE_DISPLAY_STATE);
	serviceMenus();
	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(SYRINGE_CONFIRMATION_STATE, _c_mainState);		// Check correct state transition
	TEST_ASSERT_EQUAL_HEX8(FALSE,getKeyChange());																// Check for reset keyChange
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_NO_KEY_input_for_SELECT_SYRINGE_INPUT_STATE(void)
{
	setTestValues(0,SELECT_SYRINGE_INPUT_STATE,NO_KEYS,SELECT_SYRINGE_DISPLAY_STATE);
	serviceMenus();
	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(SELECT_SYRINGE_INPUT_STATE, _c_mainState);		// Check no state transition
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SYRINGE_CONFIRMATION_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,SYRINGE_CONFIRMATION_STATE,fetchKey(count),SELECT_SYRINGE_INPUT_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(SYRINGE_CONFIRMATION_STATE, _c_mainState);  // Check for correct state transition

		setTestValues(TWO_SEC_TIMEOUT + 1,SYRINGE_CONFIRMATION_STATE,fetchKey(count),SELECT_SYRINGE_INPUT_STATE);
		putPurgeEnabled(FALSE);
		change_infusion_ready_state_to(FAST_TRACK_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(TWENTY_FOUR_HOUR_INFUSION_DISPLAY_STATE, _c_mainState);  // Check for correct state transition

		setTestValues(TWO_SEC_TIMEOUT + 1,SYRINGE_CONFIRMATION_STATE,fetchKey(count),SELECT_SYRINGE_INPUT_STATE);
		putPurgeEnabled(FALSE);
		change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);  // Check for correct state transition

		setTestValues(TWO_SEC_TIMEOUT + 1,SYRINGE_CONFIRMATION_STATE,fetchKey(count),SELECT_SYRINGE_INPUT_STATE);
		putPurgeEnabled(TRUE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(PURGE_DISPLAY_STATE, _c_mainState);  // Check for correct state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_UNRECOGNISED_SYRINGE_DISPLAY_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,UNRECOGNISED_SYRINGE_DISPLAY_STATE,fetchKey(count),INSERT_CORRECT_SYRINGE_INPUT_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(UNRECOGNISED_SYRINGE_INPUT_STATE, _c_mainState);  // Check for correct state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_UP_DOWN_LEFT_KEY_input_for_UNRECOGNISED_SYRINGE_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		switch(testKey)
		{
			case KEY_UP:
			case KEY_DOWN:
			case KEY_LEFT:
				setTestValues(0,UNRECOGNISED_SYRINGE_INPUT_STATE,testKey,UNRECOGNISED_SYRINGE_DISPLAY_STATE);
				putKeyChange(TRUE); 																																					// setup keypress
				serviceMenus();
				TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
				TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);  // Check for correct state transition
				break;
			case KEY_RIGHT:
			case KEY_ENTER:
			case NO_KEYS:
				break;
		}
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_RIGHT_KEY_input_for_UNRECOGNISED_SYRINGE_INPUT_STATE(void)
{
	setTestValues(0,UNRECOGNISED_SYRINGE_INPUT_STATE,KEY_RIGHT,UNRECOGNISED_SYRINGE_DISPLAY_STATE);
	serviceMenus();
	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(INSERT_CORRECT_SYRINGE_DISPLAY_STATE, _c_mainState);  // Check for correct state transition
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ENTER_NO_KEY_input_for_UNRECOGNISED_SYRINGE_INPUT_STATE(void)
{
	setTestValues(0,UNRECOGNISED_SYRINGE_INPUT_STATE,KEY_ENTER,UNRECOGNISED_SYRINGE_DISPLAY_STATE);
	serviceMenus();
	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(UNRECOGNISED_SYRINGE_INPUT_STATE, _c_mainState);  // Check for correct state transition

	setTestValues(0,UNRECOGNISED_SYRINGE_INPUT_STATE,NO_KEYS,UNRECOGNISED_SYRINGE_DISPLAY_STATE);
	serviceMenus();
	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(UNRECOGNISED_SYRINGE_INPUT_STATE, _c_mainState);  // Check for correct state transition

	setTestValues(MENU_TIMEOUT + 1,UNRECOGNISED_SYRINGE_INPUT_STATE,NO_KEYS,UNRECOGNISED_SYRINGE_DISPLAY_STATE);
	serviceMenus();
	TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
	TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);  // Check for correct state transition
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CHECK_XY_PAD_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,CHECK_XY_PAD_STATE,fetchKey(count),NEW_INFUSION_INPUT_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(CHECK_XY_PAD_STATE, _c_mainState);         // Check for no state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CHECK_CARRIAGE_HEAD_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,CHECK_CARRIAGE_HEAD_STATE,fetchKey(count),CHECK_XY_PAD_STATE);
		putKeyChange(TRUE); 																																					// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(CHECK_CASE_CLOSED_STATE, _c_mainState);  // Check for no state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_PURGE_DISPLAY_STATE(void)
{
	uchar count;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		setTestValues(0,PURGE_DISPLAY_STATE,fetchKey(count),PURGE_INPUT_STATE);
		putKeyChange(TRUE); 																							// setup keypress
		_c_purgeState = NO_PRIME_EXTENSION_MODE;
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);				// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(PURGE_INPUT_STATE, _c_mainState);        // Check for no state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_PURGE_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);

		_c_purgeState = NO_PRIME_EXTENSION_MODE;
		setTestValues(0,PURGE_INPUT_STATE,testKey,PURGE_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(CHECK_XY_PAD_STATE, _c_mainState);   // Check for correct state transition
		TEST_ASSERT_EQUAL_HEX8(NULL_PURGE_MODE, _c_purgeState);     // Check for correct purge state transition

		_c_purgeState = INIT_PRIME_EXTENSION_MODE;
		setTestValues(0,PURGE_INPUT_STATE,testKey,PURGE_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_YES:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(PURGE_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(PRIME_EXTENSION_MODE, _c_purgeState);     // Check for correct purge state transition
        break;
  		case KEY_NO:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(CHECK_XY_PAD_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(NULL_PURGE_MODE, _c_purgeState);     // Check for correct purge state transition
        break;
    }

    _c_purgeState = PURGE_MODE;
		setTestValues(0,PURGE_INPUT_STATE,testKey,PURGE_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_UP:
  		case KEY_DOWN:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(NULL_PURGE_MODE, _c_purgeState);     // Check for correct purge state transition
        break;
      case KEY_YES:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(PURGING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(PURGE_MODE, _c_purgeState);     // Check for correct purge state transition
    		break;
      case KEY_NO:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(NULL_PURGE_MODE, _c_purgeState);     // Check for correct purge state transition
         break;
      case KEY_ENTER:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(PURGE_INPUT_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(PURGE_MODE, _c_purgeState);     // Check for correct purge state transition
         break;
      case NO_KEYS:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(PURGE_INPUT_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(PURGE_MODE, _c_purgeState);     // Check for correct purge state transition
         break;
    }

    _c_purgeState = PRIME_EXTENSION_MODE;
		setTestValues(0,PURGE_INPUT_STATE,testKey,PURGE_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_UP:
  		case KEY_DOWN:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(NULL_PURGE_MODE, _c_purgeState);     // Check for correct purge state transition
        break;
      case KEY_YES:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(PURGING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(PRIME_EXTENSION_MODE, _c_purgeState);     // Check for correct purge state transition
    		break;
      case KEY_NO:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(NULL_PURGE_MODE, _c_purgeState);     // Check for correct purge state transition
         break;
      case KEY_ENTER:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(PURGE_INPUT_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(PRIME_EXTENSION_MODE, _c_purgeState);     // Check for correct purge state transition
         break;
      case NO_KEYS:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(PURGE_INPUT_STATE, _c_mainState);   // Check for correct state transition
    		TEST_ASSERT_EQUAL_HEX8(PRIME_EXTENSION_MODE, _c_purgeState);     // Check for correct purge state transition
         break;
    }
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_PURGING_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);

		setTestValues(0,PURGING_DISPLAY_STATE,testKey,PURGE_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(PURGING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
		TEST_ASSERT_EQUAL_HEX8(PRIME_EXTENSION_MODE, _c_purgeState);     // Check for correct purge state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_PURGING_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);

		setTestValues(0,PURGING_INPUT_STATE,testKey,PURGING_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(STOPPING_PURGE_STATE, _c_mainState);   // Check for correct state transition
		TEST_ASSERT_EQUAL_HEX8(PRIME_EXTENSION_MODE, _c_purgeState);     // Check for correct purge state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_STOPPING_PURGE_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);

		setTestValues(0,STOPPING_PURGE_STATE,testKey,PURGING_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(STOPPED_PURGE_STATE, _c_mainState);   // Check for correct state transition
		TEST_ASSERT_EQUAL_HEX8(PRIME_EXTENSION_MODE, _c_purgeState);     // Check for correct purge state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_STOPPED_PURGE_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);

		setTestValues(0,STOPPED_PURGE_STATE,testKey,STOPPING_PURGE_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(PURGE_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
		TEST_ASSERT_EQUAL_HEX8(PRIME_EXTENSION_MODE, _c_purgeState);     // Check for correct purge state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_TWENTY_FOUR_HOUR_INFUSION_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);

		setTestValues(0,TWENTY_FOUR_HOUR_INFUSION_DISPLAY_STATE,testKey,SYRINGE_CONFIRMATION_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(TWENTY_FOUR_HOUR_INFUSION_INPUT_STATE, _c_mainState);   // Check for correct state transition
		TEST_ASSERT_EQUAL_HEX8(PRIME_EXTENSION_MODE, _c_purgeState);     // Check for correct purge state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_TWENTY_FOUR_HOUR_INFUSION_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);

		setTestValues(0,TWENTY_FOUR_HOUR_INFUSION_INPUT_STATE,testKey,TWENTY_FOUR_HOUR_INFUSION_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		put_rate_params_within_limits(FALSE);
 		TEST_ASSERT_EQUAL_HEX8(FALSE, get_rate_params_within_limits());	// Check for no system alarm generated
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(SET_RATE_MODE_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition

		setTestValues(0,TWENTY_FOUR_HOUR_INFUSION_INPUT_STATE,testKey,TWENTY_FOUR_HOUR_INFUSION_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		put_rate_params_within_limits(TRUE);
 		TEST_ASSERT_EQUAL_HEX8(TRUE, get_rate_params_within_limits());	// Check for no system alarm generated
		serviceMenus();
    switch(testKey)
		{
  		case KEY_LEFT:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(SET_RATE_MODE_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
    		break;
  		case KEY_RIGHT:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(TWENTY_FOUR_HOUR_INFUSION_INPUT_STATE, _c_mainState);   // Check for correct state transition
    		break;
			case KEY_UP:
			case KEY_DOWN:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
    		break;
    	default:
    		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    		TEST_ASSERT_EQUAL_HEX8(TWENTY_FOUR_HOUR_INFUSION_INPUT_STATE, _c_mainState);   // Check for correct state transition
    		break;
    }
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CONFIRM_TO_RUN_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;

	TEST_IGNORE(); //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		secLCDType[0] = LCD_NONE;
		setTestValues(0,CONFIRM_TO_RUN_DISPLAY_STATE,testKey,CHECK_CASE_CLOSED_INPUT_STATE);
		change_infusion_ready_state_to(RATE_SET_LOADED);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(CONFIRM_TO_RUN_SEND_SECONDARY_WAIT_STATE, _c_mainState);   // Check for correct state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CONFIRM_TO_RUN_SEND_SECONDARY_WAIT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		secLCDType[0] = LCD_NONE;
		setTestValues(0,CONFIRM_TO_RUN_SEND_SECONDARY_WAIT_STATE,testKey,CONFIRM_TO_RUN_DISPLAY_STATE);
//		change_infusion_ready_state_to(RATE_SET_LOADED);
    put_new_rate_values_confirm(TRUE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(CONFIRM_TO_RUN_INPUT_STATE, _c_mainState);   // Check for correct state transition

    put_new_rate_values_confirm(FALSE);
		putKeyChange(TRUE); 																				// setup keypress
		setTestValues(0,CONFIRM_TO_RUN_SEND_SECONDARY_WAIT_STATE,testKey,CONFIRM_TO_RUN_DISPLAY_STATE);
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(FALSE, get_new_rate_values_confirm());
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(CONFIRM_TO_RUN_SEND_SECONDARY_WAIT_STATE, _c_mainState);   // Check for correct state transition
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CONFIRM_TO_RUN_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		secLCDType[0] = LCD_NONE;
		setTestValues(0,CONFIRM_TO_RUN_INPUT_STATE,testKey,CONFIRM_TO_RUN_SEND_SECONDARY_WAIT_STATE);
		change_infusion_ready_state_to(RATE_SET_LOADED);
//    put_new_rate_values_confirm(TRUE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  	    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		    TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
		    break;
  		case KEY_RIGHT:
  	    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		    TEST_ASSERT_EQUAL_HEX8(ATTEMPT_TO_RUN_STATE, _c_mainState);   // Check for correct state transition
		    break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
  	    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		    TEST_ASSERT_EQUAL_HEX8(CONFIRM_TO_RUN_INPUT_STATE, _c_mainState);   // Check for correct state transition
		    break;
		}
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CONFIRM_TITRATION_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		secLCDType[0] = LCD_NONE;
    _c_infusionProgressState = INFUSION_STARTED_STATE;
		setTestValues(0,CONFIRM_TITRATION_DISPLAY_STATE,testKey,CONFIRM_TITRATION_DISPLAY_STATE);
		change_infusion_ready_state_to(RATE_SET_LOADED);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(CURRENTLY_UNIMPLEMENTED, sysAlarmRef);	// Check for no system alarm generated
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CONFIRM_TITRATION_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,CONFIRM_TITRATION_INPUT_STATE,testKey,CONFIRM_TITRATION_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(CURRENTLY_UNIMPLEMENTED, sysAlarmRef);	// Check for no system alarm generated
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CONFIRM_TITRATION_WAIT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,CONFIRM_TITRATION_WAIT_STATE,testKey,CONFIRM_TITRATION_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(CURRENTLY_UNIMPLEMENTED, sysAlarmRef);	// Check for no system alarm generated
	}
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_RATE_MODE_MENU_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	_c_is_rate_mode_enabled[VTBI_TIME_MODE] = FALSE;
    _c_is_rate_mode_enabled[TIMED_MODE] = TRUE;
    _c_is_rate_mode_enabled[CONTINUOUS_MODE] = FALSE;
		testKey = fetchKey(count);
		setTestValues(0,SET_RATE_MODE_MENU_DISPLAY_STATE,testKey,MAIN_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_RATE_DISPLAY_STATE, _c_mainState);   // Check for correct state transition

    _c_is_rate_mode_enabled[CONTINUOUS_MODE] = TRUE;
		setTestValues(0,SET_RATE_MODE_MENU_DISPLAY_STATE,testKey,MAIN_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_RATE_MODE_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition

  	_c_is_rate_mode_enabled[VTBI_TIME_MODE] = TRUE;
		setTestValues(0,SET_RATE_MODE_MENU_DISPLAY_STATE,testKey,MAIN_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_RATE_MODE_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_RATE_MODE_MENU_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_RATE_MODE_MENU_INPUT_STATE,testKey,SET_RATE_MODE_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_RATE_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
      case KEY_DOWN:
      case KEY_RIGHT:
      case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_RATE_MODE_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
      case KEY_LEFT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_RATE_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_RATE_DISPLAY_STATE,testKey,SET_RATE_MODE_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_RATE_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_RATE_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_RATE_INPUT_STATE,testKey,SET_RATE_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case NO_KEYS:
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_RATE_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_RATE_UPDATE_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_RATE_UPDATE_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_RATE_UPDATE_DISPLAY_STATE,testKey,SET_RATE_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_RATE_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CONFIRM_RATE_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		secLCDType[0] = LCD_NONE;
		testKey = fetchKey(count);
		setTestValues(0,CONFIRM_RATE_DISPLAY_STATE,testKey,TWENTY_FOUR_HOUR_INFUSION_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(CONFIRM_RATE_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_CONFIRM_RATE_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		secLCDType[0] = LCD_NONE;
		put_new_rate_values_confirm(TRUE);
		testKey = fetchKey(count);
		setTestValues(0,CONFIRM_RATE_INPUT_STATE,testKey,CONFIRM_RATE_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(PURGE_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(CONFIRM_RATE_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_ATTEMPT_TO_RUN_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		secLCDType[0] = LCD_NONE;
		put_new_rate_values_confirm(TRUE);
		testKey = fetchKey(count);
		setTestValues(0,ATTEMPT_TO_RUN_STATE,testKey,CONFIRM_TO_RUN_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(INCORRECT_PERMISSION_TO_RUN_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_INCORRECT_PERMISSION_TO_RUN_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		secLCDType[0] = LCD_NONE;
		put_new_rate_values_confirm(TRUE);
		testKey = fetchKey(count);
		setTestValues(0,INCORRECT_PERMISSION_TO_RUN_STATE,testKey,ATTEMPT_TO_RUN_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(INCORRECT_PERMISSION_TO_RUN_STATE, _c_mainState);   // Check for correct state transition

		secLCDType[0] = LCD_NONE;
		put_new_rate_values_confirm(TRUE);
		testKey = fetchKey(count);
		setTestValues(4,INCORRECT_PERMISSION_TO_RUN_STATE,testKey,ATTEMPT_TO_RUN_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition

  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_RUNNING_WAIT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,RUNNING_WAIT_STATE,testKey,ATTEMPT_TO_RUN_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(RUNNING_WAIT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_RUNNING_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,RUNNING_DISPLAY_STATE,testKey,RUNNING_WAIT_STATE);
		change_run_state_to(RUNNING_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(RUNNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_RUNNING_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,RUNNING_INPUT_STATE,testKey,RUNNING_DISPLAY_STATE);
    putKeypadLocked(FALSE);
		//change_run_state_to(RUNNING_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RUNNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
  		  break;
    }
		setTestValues(0,RUNNING_INPUT_STATE,testKey,RUNNING_DISPLAY_STATE);
    putKeypadLocked(TRUE);
		//change_run_state_to(RUNNING_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
      case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(KEYLOCK_WARNING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RUNNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SERVICE_WARNING_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	//#define testKey count
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SERVICE_WARNING_DISPLAY_STATE,testKey,WARNING_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SERVICE_WARNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
	//#undef testKey
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SERVICE_WARNING_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SERVICE_WARNING_INPUT_STATE,testKey,SERVICE_WARNING_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SERVICE_WARNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(NEW_INFUSION_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_BAT_WARNING_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		_c_batState = BAT_WARNING_2_HOURS_STATE;
		setTestValues(0,BAT_WARNING_DISPLAY_STATE,testKey,BAT_WARNING_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(BAT_WARNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_BAT_WARNING_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		_c_batState = BAT_WARNING_2_HOURS_STATE;
		setTestValues(0,BAT_WARNING_DISPLAY_STATE,testKey,BAT_WARNING_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
  		  TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(BAT_WARNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
		setTestValues(0,BAT_WARNING_DISPLAY_STATE,testKey,BAT_WARNING_DISPLAY_STATE);
    _c_batState == BAT_WARNING_LOW_STATE;
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_RIGHT:
  		  TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(BAT_WARNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
  		  TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(BAT_WARNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_NEOI_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;

	TEST_IGNORE(); //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		_c_batState = BAT_WARNING_2_HOURS_STATE;
		setTestValues(0,NEOI_DISPLAY_STATE,testKey,BAT_WARNING_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(NEOI_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_NEOI_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	change_neoi_state_to(NEOI_WARNING_STATE);
		testKey = fetchKey(count);
		setTestValues(0,NEOI_INPUT_STATE,testKey,NEOI_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		putKeypadLocked(FALSE);
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(NEOI_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(NEOI_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  	change_neoi_state_to(NEOI_RUNNING_STATE);
		testKey = fetchKey(count);
		setTestValues(0,NEOI_INPUT_STATE,testKey,NEOI_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		putKeypadLocked(FALSE);
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
          TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(NEOI_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  	change_neoi_state_to(NEOI_RUNNING_STATE);
		testKey = fetchKey(count);
		setTestValues(0,NEOI_INPUT_STATE,testKey,NEOI_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		putKeypadLocked(TRUE);
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(KEYLOCK_WARNING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(NEOI_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_EOI_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		change_eoi_state_to(EOI_WARNING_STATE);
		_c_eoi_mode = EOI_STOP_MODE;
		setTestValues(0,EOI_DISPLAY_STATE,testKey,OPTIONS_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(EOI_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_EOI_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	change_eoi_state_to(EOI_WARNING_STATE);
		testKey = fetchKey(count);
		setTestValues(0,EOI_INPUT_STATE,testKey,EOI_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		putKeypadLocked(FALSE);
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(EOI_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  	change_eoi_state_to(EOI_RUNNING_STATE);
		testKey = fetchKey(count);
		setTestValues(0,EOI_INPUT_STATE,testKey,EOI_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		putKeypadLocked(FALSE);
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(EOI_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  	change_eoi_state_to(EOI_RUNNING_STATE);
		testKey = fetchKey(count);
		setTestValues(0,EOI_INPUT_STATE,testKey,EOI_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		putKeypadLocked(TRUE);
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(KEYLOCK_WARNING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(EOI_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_OPTIONS_MENU_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,OPTIONS_MENU_DISPLAY_STATE,testKey,MAIN_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(OPTIONS_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_OPTIONS_MENU_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		change_run_state_to(STOPPED_STATE);
		setTestValues(0,OPTIONS_MENU_INPUT_STATE,testKey,OPTIONS_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(OPTIONS_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_DOWN:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(OPTIONS_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RESET_TVI_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(OPTIONS_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_MAIN_MENU_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,MAIN_MENU_DISPLAY_STATE,testKey,TWENTY_FOUR_HOUR_INFUSION_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_MAIN_MENU_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		putKeypadLocked(FALSE);
		setTestValues(0,MAIN_MENU_INPUT_STATE,testKey,MAIN_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFO_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INSERT_CORRECT_SYRINGE_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
		putKeypadLocked(TRUE);
		setTestValues(0,MAIN_MENU_INPUT_STATE,testKey,MAIN_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(KEYLOCK_WARNING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SETUP_MENU_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SETUP_MENU_DISPLAY_STATE,testKey,MAIN_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SETUP_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SETUP_MENU_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
  change_run_state_to(STOPPED_STATE);
  change_menu_position_to(DATE_TIME_POSITION);
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SETUP_MENU_INPUT_STATE,testKey,SETUP_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(DATE_TIME_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }

    change_menu_position_to(DATE_TIME_POSITION);
		setTestValues(0,SETUP_MENU_INPUT_STATE,testKey,SETUP_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(DATE_TIME_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }

    change_menu_position_to(SYSTEM_POSITION);
		setTestValues(0,SETUP_MENU_INPUT_STATE,testKey,SETUP_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_SYSTEM_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }

    change_menu_position_to(INFUSION_POSITION);
		setTestValues(0,SETUP_MENU_INPUT_STATE,testKey,SETUP_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFUSION_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }

    change_menu_position_to(OCCLUSION_POSITION);
		setTestValues(0,SETUP_MENU_INPUT_STATE,testKey,SETUP_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(OCCLUSION_PRESSURE_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }

    change_menu_position_to(KEY_CLICK_POSITION);
		setTestValues(0,SETUP_MENU_INPUT_STATE,testKey,SETUP_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_KEY_CLICK_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }

    change_menu_position_to(KEY_LOCK_POSITION);
		setTestValues(0,SETUP_MENU_INPUT_STATE,testKey,SETUP_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(KEY_LOCK, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_DATE_TIME_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,DATE_TIME_DISPLAY_STATE,testKey,SETUP_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(DATE_TIME_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_DATE_TIME_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	change_run_state_to(STOPPED_STATE);
		testKey = fetchKey(count);
		setTestValues(0,DATE_TIME_INPUT_STATE,testKey,DATE_TIME_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(DATE_TIME_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SETUP_SYSTEM_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SETUP_SYSTEM_DISPLAY_STATE,testKey,SETUP_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SETUP_SYSTEM_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SETUP_SYSTEM_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	change_run_state_to(STOPPED_STATE);
		testKey = fetchKey(count);
		setTestValues(0,SETUP_SYSTEM_INPUT_STATE,testKey,SETUP_SYSTEM_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SETUP_SYSTEM_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_INFUSION_MENU_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,INFUSION_MENU_DISPLAY_STATE,testKey,SETUP_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(INFUSION_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_INFUSION_MENU_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	change_menu_position_to(SET_NEOI_POSITION);
  	change_run_state_to(STOPPED_STATE);
		testKey = fetchKey(count);
		setTestValues(0,INFUSION_MENU_INPUT_STATE,testKey,INFUSION_MENU_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_NEOI_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFUSION_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFUSION_MENU_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_RESET_TVI_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,RESET_TVI_DISPLAY_STATE,testKey,OPTIONS_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(RESET_TVI_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_RESET_TVI_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	change_run_state_to(RUNNING_STATE);
		testKey = fetchKey(count);
		setTestValues(0,RESET_TVI_INPUT_STATE,testKey,RESET_TVI_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RESET_TVI_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RESET_TVI_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RUNNING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RESET_TVI_CONFIRMATION_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RESET_TVI_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_RESET_TVI_CONFIRMATION_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	change_run_state_to(RUNNING_STATE);
		testKey = fetchKey(count);
		setTestValues(0,RESET_TVI_CONFIRMATION_STATE,testKey,RESET_TVI_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
  		case NO_KEYS:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RESET_TVI_CONFIRMATION_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RUNNING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_VIEW_LOGS_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,VIEW_LOGS_DISPLAY_STATE,testKey,OPTIONS_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(VIEW_LOGS_WAIT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_VIEW_LOGS_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,VIEW_LOGS_INPUT_STATE,testKey,VIEW_LOGS_WAIT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(OPTIONS_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(VIEW_LOGS_INPUT_STATE, _c_mainState);   // Check for correct state transition
		break;
  		case KEY_DOWN:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(VIEW_LOGS_WAIT_STATE, _c_mainState);   // Check for correct state transition
		break;
  		case KEY_RIGHT:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(VIEW_LOGS_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(VIEW_DETAIL_LOG_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;

    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_VIEW_DETAIL_LOG_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,VIEW_DETAIL_LOG_DISPLAY_STATE,testKey,VIEW_LOGS_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(VIEW_DETAIL_LOG_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_VIEW_DETAIL_LOG_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,VIEW_DETAIL_LOG_INPUT_STATE,testKey,VIEW_DETAIL_LOG_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(VIEW_LOGS_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(VIEW_DETAIL_LOG_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_OCCLUSION_PRESSURE_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,OCCLUSION_PRESSURE_DISPLAY_STATE,testKey,SETUP_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(OCCLUSION_PRESSURE_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_OCCLUSION_PRESSURE_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,OCCLUSION_PRESSURE_INPUT_STATE,testKey,OCCLUSION_PRESSURE_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFUSION_MENU_WAIT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(OCCLUSION_PRESSURE_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_INFUSION_MENU_WAIT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,INFUSION_MENU_WAIT_STATE,testKey,OCCLUSION_PRESSURE_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(INFUSION_MENU_WAIT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_NEOI_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_NEOI_DISPLAY_STATE,testKey,INFUSION_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_NEOI_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_NEOI_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_NEOI_INPUT_STATE,testKey,SET_NEOI_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_NEOI_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_EOI_PERCENT_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_EOI_PERCENT_DISPLAY_STATE,testKey,INFUSION_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_EOI_PERCENT_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_EOI_PERCENT_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_EOI_PERCENT_INPUT_STATE,testKey,SET_EOI_PERCENT_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_EOI_PERCENT_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_EOI_MODE_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_EOI_MODE_DISPLAY_STATE,testKey,INFUSION_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_EOI_MODE_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_EOI_MODE_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_EOI_MODE_INPUT_STATE,testKey,SET_EOI_MODE_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFUSION_MENU_WAIT_STATE, _c_mainState);   // Check for correct state transition
        //TEST_ASSERT_EQUAL_HEX8(SET_EOI_MODE_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_EOI_MODE_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_KVO_RATE_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_KVO_RATE_DISPLAY_STATE,testKey,INFUSION_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_KVO_RATE_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_KVO_RATE_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_KVO_RATE_INPUT_STATE,testKey,SET_KVO_RATE_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_KVO_RATE_INPUT_STATE, _c_mainState);   // Check for correct state transition
        //TEST_ASSERT_EQUAL_HEX8(SET_KVO_RATE_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_KVO_RATE_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_TITRATION_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_TITRATION_DISPLAY_STATE,testKey,INFUSION_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_TITRATION_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_TITRATION_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		secLCDType[0] = LCD_NONE;
		testKey = fetchKey(count);
		setTestValues(0,SET_TITRATION_INPUT_STATE,testKey,SET_TITRATION_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_TITRATION_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_TITRATION_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
//  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFUSION_MENU_WAIT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFUSION_MENU_WAIT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_INFO_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,INFO_DISPLAY_STATE,testKey,MAIN_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(INFO_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_INFO_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		secLCDType[0] = LCD_NONE;
		testKey = fetchKey(count);
		setTestValues(0,INFO_INPUT_STATE,testKey,INFO_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFO_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFO_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(INFO_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_KEYLOCK_WARNING_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,KEYLOCK_WARNING_DISPLAY_STATE,testKey,RUNNING_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(KEYLOCK_WARNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_KEYLOCK_WARNING_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		secLCDType[0] = LCD_NONE;
		testKey = fetchKey(count);
		setTestValues(0,KEYLOCK_WARNING_INPUT_STATE,testKey,KEYLOCK_WARNING_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
 		  case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(KEYLOCK_WARNING_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(KEYLOCK_PRE_UNLOCK, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_BOLUS_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	change_run_state_to(RUNNING_STATE);
		testKey = fetchKey(count);
		setTestValues(0,BOLUS_STATE,testKey,MAIN_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(RUNNING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition

  	change_run_state_to(NEOI_STATE);
		testKey = fetchKey(count);
		setTestValues(0,BOLUS_STATE,testKey,MAIN_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(NEOI_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_BOLUS1_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  _c_infusedBolus = 1;
  _i_infusedBolus = 0xFE;
  _c_bolusVolume = 1;
  _i_bolusVolume = 0xFE;

	putMaxRate(100.0);
  	change_run_state_to(RUNNING_STATE);
  	vStateBufPtr = 0;
		testKey = fetchKey(count);
		setTestValues(0,BOLUS1_STATE,testKey,BOLUS_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		  switch(testKey)
  		{
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(BOLUS1_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(RUNNING_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_BOLUS2_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	_c_rate_value = 200.0;
  	change_run_state_to(RUNNING_STATE);
		testKey = fetchKey(count);
		setTestValues(0,BOLUS2_STATE,testKey,BOLUS1_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(BOLUS2_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(BOLUS_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_KEY_CLICK_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_KEY_CLICK_DISPLAY_STATE,testKey,SETUP_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_KEY_CLICK_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_KEY_CLICK_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_KEY_CLICK_INPUT_STATE,testKey,SET_KEY_CLICK_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_KEY_CLICK_CONFIRMATION_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SET_KEY_CLICK_INPUT_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_KEY_CLICK_CONFIRMATION_STATE(void)
{
	uchar count;
	uchar testKey;
	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_KEY_CLICK_CONFIRMATION_STATE,testKey,SET_KEY_CLICK_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_KEY_CLICK_CONFIRMATION_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_DISPLAY_LOCK(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	secLCDType[0] = LCD_NONE;
		testKey = fetchKey(count);
		setTestValues(0,DISPLAY_LOCK,testKey,KEY_LOCK1);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(DISPLAY_LOCK1, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_DISPLAY_LOCK1(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
  	secLCDType[0] = LCD_NONE;
		testKey = fetchKey(count);
		setTestValues(0,DISPLAY_LOCK1,testKey,DISPLAY_LOCK);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(DISPLAY_LOCK1, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SHUTDOWN_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SHUTDOWN_STATE,testKey,MAIN_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SHUTDOWN1_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SHUTDOWN1_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SHUTDOWN1_STATE,testKey,SHUTDOWN_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(MAIN_MENU_DISPLAY_STATE, _c_mainState);   // Check for correct state transition
        break;
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(SHUTDOWN1_STATE, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_WAIT_SHUTDOWN(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,WAIT_SHUTDOWN,testKey,SHUTDOWN1_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(WAIT_SHUTDOWN, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_OCCLUSION_BACKOFF(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,OCCLUSION_BACKOFF,testKey,RUNNING_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(OCCLUSION_BACKOFF, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_OCCLUSION_BACKOFF_2(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,OCCLUSION_BACKOFF_2,testKey,OCCLUSION_BACKOFF);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(OCCLUSION_BACKOFF_3, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_OCCLUSION_BACKOFF_3(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		_c_rate_value = 200.0;
		mlPool = 1000;
		_c_mmPool = mlPool;
		_i_mmPool = ~_c_mmPool;
		_c_startPosition = 5000;
		_i_startPosition = ~_c_startPosition;
		_c_carriagePos = 4500;
		_i_carriagePos = ~_c_carriagePos;



		_c_syringeType = 0;
		_i_syringeType = ~_c_syringeType;
		readSyringeDataFromTable();

		testKey = fetchKey(count);
		setTestValues(0,OCCLUSION_BACKOFF_3,testKey,OCCLUSION_BACKOFF_2);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
		TEST_ASSERT_EQUAL_HEX8(OCCLUSION_BACKOFF_3, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_KEYLOCK_PRE_UNLOCK(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,KEYLOCK_PRE_UNLOCK,testKey,KEYLOCK_WARNING_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(KEYLOCK_PRE_UNLOCK_1, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_KEYLOCK_PRE_UNLOCK_1(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,KEYLOCK_PRE_UNLOCK_1,testKey,KEYLOCK_PRE_UNLOCK);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(KEYLOCK_PRE_UNLOCK_1, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_TECHNICIAN_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,TECHNICIAN_STATE,testKey,TECHNICIAN_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(TECHNICIAN_STATE_ENTERED, sysAlarmRef);	// Check for no system alarm generated
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_KEY_LOCK(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,KEY_LOCK,testKey,SETUP_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(KEY_LOCK1, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_KEY_LOCK1(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,KEY_LOCK1,testKey,KEY_LOCK);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch (testKey)
		{
  		case NO_KEYS:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(KEY_LOCK1, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_LEFT:
  		case KEY_RIGHT:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(DISPLAY_LOCK, _c_mainState);   // Check for correct state transition
        break;
  		case KEY_UP:
  		case KEY_DOWN:
  		case KEY_ENTER:
        TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
        TEST_ASSERT_EQUAL_HEX8(KEY_LOCK1, _c_mainState);   // Check for correct state transition
        break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_BOLUS_DISPLAY_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_BOLUS_DISPLAY_STATE,testKey,INFUSION_MENU_INPUT_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
    TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
    TEST_ASSERT_EQUAL_HEX8(SET_BOLUS_INPUT_STATE, _c_mainState);   // Check for correct state transition
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

void test_ALL_KEY_input_for_SET_BOLUS_INPUT_STATE(void)
{
	uchar count;
	uchar testKey;

	for(count = 0; count < NUMBER_OF_KEYS; count++)
	{
		testKey = fetchKey(count);
		setTestValues(0,SET_BOLUS_INPUT_STATE,testKey,SET_BOLUS_DISPLAY_STATE);
		putKeyChange(TRUE); 																				// setup keypress
		serviceMenus();
		switch(testKey)
		{
  		case KEY_LEFT:
  		case KEY_RIGHT:
  		case KEY_UP:
  		case KEY_DOWN:
  		case NO_KEYS:
      TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
      TEST_ASSERT_EQUAL_HEX8(SET_BOLUS_INPUT_STATE, _c_mainState);   // Check for correct state transition
      break;
  		case KEY_ENTER:
      TEST_ASSERT_EQUAL_HEX8(NO_SYSTEM_ALARM_ERROR, sysAlarmRef);	// Check for no system alarm generated
      TEST_ASSERT_EQUAL_HEX8(INFUSION_MENU_WAIT_STATE, _c_mainState);   // Check for correct state transition
      break;
    }
  }
}

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

