
#ifndef TEST
  #include "p18f8720.h"
#else
//  #include "inttypes.h"
#endif

#include "defs.h"
#include "global_vars.h"
#include "cfr.h"
#include "alarms.h"
#include "flowCheck.h"
#include "systemAlarm.h"
#include "menuControl.h"
#include "setRate.h"
#include "flash.h"
#include "serial.h"
#include "stateMachineRoutines.h"
#include "infusion.h"

#pragma code

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

/** \ingroup safety
  * check_for_alarms() tests for alarms currently unactivated.
  * If an alarm is detected, the appropriate action is taken to alert the user and abort the infusion.
  */

void check_for_alarms(void)
  {
  switch (_c_alarmState)
    {
    case NO_ALARM_STATE:                            // no current alarm so check for new alarms

//  .   .   .   test cover...

      if(getLidShut() == FALSE)
        {
        switch(_c_runState)
          {
          case RUNNING_STATE:
          case NEOI_STATE:
          case EOI_STATE:
            if(_c_runState == EOI_STATE)
              {
              change_run_state_to(STOPPED_STATE);
              change_alarm_state_to(CASE_OPEN_ALARM_STATE);
              change_main_state_to(ALARM_DISPLAY_STATE);
              change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
              sendSecondary(SEC_STOPRUN);
              stopInfusion();
              check_for_active_bat_warning();
              change_warning_state_to(NO_WARNING_ACTIVE_STATE);
              }
            else
              {
              sendSecondary(SEC_STOPRUN);
              stopInfusion();
              change_alarm_state_to(CASE_OPEN_ALARM_STATE);
              check_for_active_bat_warning();
              if(_c_infusionReadyState == RATE_UNSET_LOADED)      // purging?
                {
                change_warning_state_to(NO_WARNING_ACTIVE_STATE);
                change_run_state_to(STOPPED_STATE);
                change_main_state_to(ALARM_DISPLAY_STATE);
                }
              else
                {
                change_warning_state_to(NO_WARNING_ACTIVE_STATE);
                change_run_state_to(PAUSED_STATE);
                change_main_state_to(ALARM_DISPLAY_STATE);
                }
              }
            break;

          case STOPPED_STATE:
          case PAUSED_STATE:
            if(_c_mainState == ATTEMPT_TO_RUN_STATE)
              {
              change_alarm_state_to(CASE_OPEN_ALARM_STATE);
              check_for_active_bat_warning();
              change_warning_state_to(NO_WARNING_ACTIVE_STATE);
              change_run_state_to(PAUSED_STATE);
              change_main_state_to(ALARM_DISPLAY_STATE);
              }
          case PURGING_STATE:
          case OCCLUDED_STATE:
            break;

          default:
            systemAlarm(UNEXPECTED_MOTOR_STATE);
          }
        }

//  .   .   .   test battery alarm...

      if(_c_batState == BAT_WARNING_DISCHARGED_STATE)
        {
        change_alarm_state_to(BAT_DISCHARGED_ALARM_STATE);
//        check_for_active_bat_warning();
        change_warning_state_to(NO_WARNING_ACTIVE_STATE);
        change_run_state_to(STOPPED_STATE);
        change_main_state_to(ALARM_DISPLAY_STATE);
        }

//  .   .   .   test syringe empty alarm...

      if(getSyringeEmpty() == TRUE)
        {
        putSyringeEmpty(FALSE);
        switch(_c_motor_state)
          {
          case FORWARD_STATE:
          
            SDL_PRINT_SYRINGE_EMPTY;
            
            sendSecondary(SEC_STOPRUN);
            stopInfusion();
            change_alarm_state_to(SYRINGE_EMPTY_ALARM_STATE);
            check_for_active_bat_warning();
            change_warning_state_to(NO_WARNING_ACTIVE_STATE);
            change_run_state_to(STOPPED_STATE);
            change_main_state_to(ALARM_DISPLAY_STATE);
            change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
	          break;
          case OFF_STATE:
            break;
          default:
            systemAlarm(UNEXPECTED_MOTOR_STATE);
            break;
          }
        }

//  .   .   .   test occlusion alarm...

      if(getOcclusion() == TRUE)
        {
        putOcclusion(FALSE);
        change_alarm_state_to(OCCLUSION_ALARM_STATE);
        check_for_active_bat_warning();
        change_warning_state_to(NO_WARNING_ACTIVE_STATE);
        change_main_state_to(ALARM_DISPLAY_STATE);
        }

//  .   .   .   test width fault...

      if(getWidthFault() == TRUE)
        {
        putWidthFault(FALSE);
        switch(_c_runState)
          {
          case STOPPED_STATE:
            break;
          default:
            sendSecondary(SEC_STOPRUN);
            stopInfusion();
            change_alarm_state_to(WIDTH_FAULT_ALARM_STATE);
            check_for_active_bat_warning();
            change_warning_state_to(NO_WARNING_ACTIVE_STATE);
            change_run_state_to(STOPPED_STATE);
            change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
            change_main_state_to(ALARM_DISPLAY_STATE);
            break;
          }
        }

//  .   .   .   test height fault...

      if(getHeightFault() == TRUE)
        {
        putHeightFault(FALSE);
        switch(_c_runState)
          {
          case STOPPED_STATE:
            break;
          default:
            sendSecondary(SEC_STOPRUN);
            stopInfusion();
            change_alarm_state_to(HEIGHT_FAULT_ALARM_STATE);
            check_for_active_bat_warning();
            change_warning_state_to(NO_WARNING_ACTIVE_STATE);
            change_run_state_to(STOPPED_STATE);
            change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
            change_main_state_to(ALARM_DISPLAY_STATE);
            break;
          }
        }

//  .   .   .   test fingerPlate fault...

      if(getFingerPlateFault() == TRUE)
        {
        putFingerPlateFault(FALSE);
        switch(_c_runState)
          {
          case STOPPED_STATE:
            break;
          default:
            sendSecondary(SEC_STOPRUN);
            stopInfusion();
            change_alarm_state_to(FINGER_PLATE_FAULT_ALARM_STATE);
            check_for_active_bat_warning();
            change_warning_state_to(NO_WARNING_ACTIVE_STATE);
            change_run_state_to(STOPPED_STATE);
            change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
            change_main_state_to(ALARM_DISPLAY_STATE);
            break;
          }
        }

//  .   .   .   test finger plate fault...

      if(getFingerPlateSwitchFault() == TRUE)
        {
        putFingerPlateSwitchFault(FALSE);
        sendSecondary(SEC_STOPRUN);
        stopInfusion();
        change_alarm_state_to(FP_SWITCH_FAULT_ALARM_STATE);
        check_for_active_bat_warning();
        change_warning_state_to(NO_WARNING_ACTIVE_STATE);
        change_run_state_to(STOPPED_STATE);
        change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
        change_main_state_to(ALARM_DISPLAY_STATE);
        }

//  .   .   .   test for lid switch fault...

      if(getLidSwitchFault() == TRUE)
        {
        putLidSwitchFault(FALSE);
            sendSecondary(SEC_STOPRUN);
            stopInfusion();
            change_alarm_state_to(LID_SWITCH_FAULT_ALARM_STATE);
            check_for_active_bat_warning();
            change_run_state_to(STOPPED_STATE);
            change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
            change_warning_state_to(NO_WARNING_ACTIVE_STATE);
            change_main_state_to(ALARM_DISPLAY_STATE);
            break;
        }

//  .   .   .   test position fault...

      if(getPositionFault() == TRUE)
        {
        putPositionFault(FALSE);
        switch(_c_runState)
          {
          case STOPPED_STATE:
            break;
          default:
            sendSecondary(SEC_STOPRUN);
            stopInfusion();
            change_alarm_state_to(POSITION_FAULT_ALARM_STATE);
            check_for_active_bat_warning();
            change_warning_state_to(NO_WARNING_ACTIVE_STATE);
            change_run_state_to(STOPPED_STATE);
            change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
            change_main_state_to(ALARM_DISPLAY_STATE);
            break;
          }
        }
      break;

//  .   .   .   check state is valid...

    case BAT_DISCHARGED_ALARM_STATE:
    case SYRINGE_EMPTY_ALARM_STATE:
    case OCCLUSION_ALARM_STATE:
    case WIDTH_FAULT_ALARM_STATE:
    case HEIGHT_FAULT_ALARM_STATE:
    case FINGER_PLATE_FAULT_ALARM_STATE:
    case POSITION_FAULT_ALARM_STATE:
    case CASE_OPEN_ALARM_STATE:
    case LID_SWITCH_FAULT_ALARM_STATE:
    case FP_SWITCH_FAULT_ALARM_STATE:
      break;

    default:
      systemAlarm(UNKNOWN_ALARM_STATE);
      break;
    }
  }

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

/** \ingroup safety
  * check_for_warnings() tests for warnings currently unactivated.
  * If a warning is detected, the appropriate action is taken to alert the user.
  */

void check_for_warnings(void)
  {
  if(_c_warningState != EOI_WARNING_ACTIVE_STATE)
    {
    if( _c_runState == OCCLUDED_STATE ||
        _c_runState == PURGING_STATE  ||
        getInfusingBolus() == TRUE    )
      {
      return;
      }
    }

  switch(_c_warningState)
    {
    case NO_WARNING_ACTIVE_STATE:
		case BAT_WARNING_ACTIVE_STATE:
      break;
    case SERVICE_WARNING_ACTIVE_STATE:
      if(getServiceDue() == FALSE)
        {
        change_main_state_to(WARNING_STATE);
        }
      break;
    case NEOI_WARNING_ACTIVE_STATE:
      switch(_c_neoiState)
        {
        case NEOI_NO_WARNING_STATE:
        	change_main_state_to(WARNING_STATE);
        	break;
        case NEOI_WARNING_STATE:
        case NEOI_RUNNING_STATE:
          break;
        default:
          systemAlarm(UNEXPECTED_NEOI_STATE);
 	        break;
 	      }
	    break;
    case EOI_WARNING_ACTIVE_STATE:
      switch(_c_eoiState)
        {
        case EOI_NO_WARNING_STATE:
        	change_main_state_to(WARNING_STATE);
        	change_infusion_progress_state_to(INFUSION_FINISHED_STATE);
        	break;
        case EOI_WARNING_STATE:
        case EOI_RUNNING_STATE:
          break;
        default:
          systemAlarm(UNEXPECTED_EOI_STATE);
          break;
        }
      break;
    default:
      systemAlarm(UNEXPECTED_WARNING_STATE);
      break;
    }
  }

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

/** \ingroup safety
  * check_for_active_bat_warning() tests for an active battery warning. If a warning is currently active, the critical variable lastBatState
  * is set to BAT_WARNING_PARKED_STATE. Following a response to an alarm, the system will re-generate the battery warning (it is parked
  * temporarily to make way for the more important alarm.
  */

void check_for_active_bat_warning(void)
  {
  switch(_c_warningState)
    {
    case BAT_WARNING_ACTIVE_STATE:
    	if (_c_lastBatState != BAT_WARNING_PARKED_STATE) {        // if a battery warning is active, park the warning to pick up later
	      _c_lastBatState = BAT_WARNING_PARKED_STATE;             // Other warnings are overwritten by the calling alarm / warning.
	      _i_lastBatState = ~BAT_WARNING_PARKED_STATE;
      }
      break;
    case NO_WARNING_ACTIVE_STATE:
    case NEOI_WARNING_ACTIVE_STATE:
    case EOI_WARNING_ACTIVE_STATE:
    case SERVICE_WARNING_ACTIVE_STATE:
      break;
    default:
      systemAlarm(UNEXPECTED_WARNING_STATE);
      break;
    }
  }

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

/** \ingroup safety
  * check_battery() tests to see if the battery charge state has changed. If it has a warning is generated.
  */

void check_battery(void)
  {
  if( _c_runState == OCCLUDED_STATE ||
      _c_runState == PURGING_STATE  ||
      getInfusingBolus() == TRUE    )
    {
    return;
    }

  if(_c_alarmState == NO_ALARM_STATE)                 // only check if currently no active alarm condition
    {
    if(_c_warningState == NO_WARNING_ACTIVE_STATE)    // only check if currently no active warning condition
      {
      if(_c_batState != _c_lastBatState)							// if change in battery state or battery warning had been put on hold...
        {
	      if (_c_batState > _c_lastBatState)						// only show the warning if the battery charge is falling
	      	{
					if(_c_purgeState == PRIME_EXTENSION_MODE)
					  {
		      	change_infusion_ready_state_to(RATE_UNSET_UNLOADED);
						change_run_state_to(STOPPED_STATE);
					  }


 	        switch(_c_batState)
	          {
		        case BAT_WARNING_USE_EMERGENCY_STATE:
		        case BAT_WARNING_HEALTHY_STATE:
		        	break;
	          case BAT_WARNING_2_HOURS_STATE:
	          case BAT_WARNING_LOW_STATE:
	          case BAT_WARNING_EMERGENCY_LOW_STATE:
	            change_warning_state_to(BAT_WARNING_ACTIVE_STATE);
	            change_main_state_to(BAT_WARNING_DISPLAY_STATE);
	            break;
	          case BAT_WARNING_DISCHARGED_STATE:
	            break;
	          default:
	            systemAlarm(UNEXPECTED_WARNING_STATE);
	            break;
	          }
		      }

        _c_lastBatState = _c_batState;                // ..update lastBatState
        _i_lastBatState = _i_batState;
        }
      }
    }
  }

//  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

#pragma code
