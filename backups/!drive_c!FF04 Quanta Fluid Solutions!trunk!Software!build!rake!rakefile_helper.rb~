module RakefileConstants
  $task = nil
  ROOT_PATH = File.expand_path(File.join(File.dirname(__FILE__),'..'))
  BUILD_PATH = File.join(ROOT_PATH,'build')
  BUILD_OUT_PATH = File.join(BUILD_PATH,'out')
  DOCS_LIB_PATH = File.join(ROOT_PATH,'docs','lib')
  require File.join(BUILD_PATH,'colour_prompt')
  require File.join(DOCS_LIB_PATH,'get_time_date.rb')
  require File.join(DOCS_LIB_PATH,'version.rb')
  require File.join(BUILD_PATH,'check_version')

  TFT_BUILD_TYPE = 'base_tft'
  CSTN_BUILD_TYPE = 'base_cstn'
  FACTORY_BUILD_TYPE = 'factory'
  SEC_TFT_BUILD_TYPE = 'sec_tft'
  SEC_CSTN_BUILD_TYPE = 'sec_cstn'
  SEC_FACTORY_BUILD_TYPE = 'sec_factory'
  TERTIARY_BUILD_TYPE = 'tertiary'
  
  PRIMARY_TFT_LINKER_FILE = File.join(ROOT_PATH,'pri','lib','base','18F8720.LKR').gsub('/','\\')
  PRIMARY_CSTN_LINKER_FILE = PRIMARY_TFT_LINKER_FILE
  PRIMARY_FACTORY_LINKER_FILE = File.join(ROOT_PATH,'pri','lib','factory','18F8720.LKR').gsub('/','\\')
  SECONDARY_LINKER_FILE = File.join(ROOT_PATH,'sec','lib','base','18F2520.LKR').gsub('/','\\')
  SEC_FACTORY_LINKER_FILE = File.join(ROOT_PATH,'sec','lib','factory','18F2520.LKR').gsub('/','\\')
  PRI_BIN_DIR = File.join(ROOT_PATH,'pri','bin')
  BUILD_FDL_PATH = File.join(BUILD_PATH, 'buildfdls')
  
  C_EXTENSION = '.c'
  OBJ_EXTENSION = '.o'
  BIN_EXTENSION = '.cof'
  PRIMARY_PROCESSOR = '18F8720'
  PRIMARY_DEFINES = '_FINAL=2'
  PRIMARY_TFT_SOURCE_PATHS = %w'../pri/lib/base ../pri/lib/common ../pri/lib/debug ../pri/lib/tft'
  PRIMARY_CSTN_SOURCE_PATHS = %w'../pri/lib/base ../pri/lib/common ../pri/lib/debug ../pri/lib/cstn'
  PRIMARY_FACTORY_SOURCE_PATHS = %w'../pri/lib/tft ../pri/lib/common ../pri/lib/factory'
  PRIMARY_LIBRARIES ='p18f8720.lib clib.lib'
  PRIMARY_LIB_PATH ="/l#{File.join(ROOT_PATH,'pri','lib','lib')}"
  PRIMARY_OPTIMIZATION ='-scs -mL -pa=4'
  PRI_OUTPUT_FILE = 'PriBase'
  PRI_FDL_UPLOAD_CODE_RANGE = '0x0000-0x1FCFF'
  PRI_PRESTO_UPLOAD_CODE_RANGE = '0x0000-0x30000D'

  SECONDARY_PROCESSOR = '18F2520'
  SEC_TFT_DEFINES = '_FINAL=2'
  SEC_CSTN_DEFINES = '_FINAL=2 -dUSE_CSTN_DISPLAY'
  SECONDARY_SOURCE_PATHS = %w'../sec/lib/base'
  SECONDARY_LIBRARIES = 'p18f2520.lib clib.lib'
  SECONDARY_OPTIMIZATION ='-mL -pa=5'
  SECONDARY_OUTPUT_FILE = 'secondary'
  SEC_TFT_BIN_DIR = File.join(ROOT_PATH,'sec','bin','sec_tft')
  SEC_CSTN_BIN_DIR = File.join(ROOT_PATH,'sec','bin','sec_cstn')

  SEC_FACTORY_DEFINES = '_FINAL=2'
  SEC_FACTORY_SOURCE_PATHS = %w'../sec/lib/factory'
  SECONDARY_LIB_PATH = "/l #{File.join(ROOT_PATH,'sec','lib','lib')}"
  SEC_FACTORY_OUTPUT_FILE = 'sec_factory'
  SEC_FACTORY_BIN_DIR = File.join(ROOT_PATH,'sec','bin','sec_factory')

  TERTIARY_PROCESSOR = '16F684'
  TERTIARY_SOURCE_PATHS = %w{../ter}
  TERTIARY_LINKER_FILE = File.join(ROOT_PATH,'ter','16F684.LKR').gsub('/','\\')
  TERTIARY_BIN_DIR = File.join(ROOT_PATH,'ter')
  
  UNIT_TEST_PATH = File.join(ROOT_PATH,'pri','lib','unit_test','tests')
  UNITY_PATH = File.join(ROOT_PATH,'pri','bin','unit_test','src')
  UNIT_TEST_SOURCE_PATHS = %w{../pri/lib/base ../pri/lib/common ../pri/lib/debug ../pri/lib/tft ../pri/lib/unit_test ../pri/bin/unit_test/src}
  UNIT_TEST_BUILD_PATH = File.join(ROOT_PATH,'pri','bin','unit_test','build')
  UNITY_SRC = File.join(UNITY_PATH,'unity.c')
  UNITY_HDR = File.join(UNITY_PATH,'unity.h')
  UNIT_TEST_COMPILER = 'gcc'
  UNIT_TEST_LINKER = 'gcc'

  SIM_PRI_SOURCE_PATHS = %w{../pri/lib/base ../pri/lib/common ../pri/lib/sim  ../pri/lib/debug ../pri/lib/tft }
  SIM_SEC_SOURCE_PATHS = %w{../sec/lib/base}
  
  SIM_SDL_SOURCE_PATHS = %w{../testing/SDLTest}
  
  SDL_PRI_BUILD_PATH = File.join(ROOT_PATH,'build','sdl_pri_build')
  SDL_SEC_BUILD_PATH = File.join(ROOT_PATH,'build','sdl_sec_build')
end


module RakefileHelpers
  include RakefileConstants
  $version = Version.new.get_version
  $build_time = GetTimeDate.read
  $formatted_build_time = $build_time.gsub(' ','_').gsub(',','_').gsub(':','_').downcase
  
  def flush_output
    $stderr.flush
    $stdout.flush
  end
  
  def report message
    puts message
    flush_output
  end

  $build_tool = nil
  
  def check_tool_versions
    $build_tool = ToolVersions.new.fetch_build_tool_info
    puts; colour_print(:narrative,"compiler =>  #{$build_tool[:compiler][:name]}")
    colour_print(:output,"  #{$build_tool[:compiler][:version]}")
    colour_puts(:success, " found");puts
    colour_print(:narrative,"assembler => #{$build_tool[:assembler][:name]}")
    colour_print(:output,"  #{$build_tool[:assembler][:version]}")
    colour_puts(:success, " found");puts
    colour_print(:narrative,"linker => #{$build_tool[:linker][:name]}")
    colour_print(:output,"  #{$build_tool[:linker][:version]}")
    colour_puts(:success, " found");puts
    colour_print(:narrative,"hex builder => #{$build_tool[:mp2hex][:name]}")
    colour_print(:output,"  #{$build_tool[:mp2hex][:version]}")
    colour_puts(:success, " found");puts
    colour_print(:narrative, "toolChain path is ")
    colour_puts(:success, "  #{$build_tool[:path][:path]}");puts
    colour_print(:narrative,"library path is ")
    colour_puts(:success,"  #{$build_tool[:library][:path]}");puts
    sleep 2
  end
  
  def delete_object_files
    colour_puts(:narrative, "deleting object files...")
    Dir[BUILD_FDL_PATH + "/*"].each do |file|
      if((not file == '.gitignore') && (not file == '.svn'))
        colour_puts :output, "deleting #{file}"
        File.delete(file)
      end
    end
    if(Dir.entries(BUILD_FDL_PATH) == ['.','..','.gitignore','.svn'] ||
       Dir.entries(BUILD_FDL_PATH) == ['.','..'] ||
       Dir.entries(BUILD_FDL_PATH) == ['.','..','.gitignore'] ||
       Dir.entries(BUILD_FDL_PATH) == ['.','..','.svn'])
      puts; colour_puts :success, "verified old object files deleted!"; puts
    else
      3.times{puts}; colour_puts :failure, "ERROR! Couldn't verify old object files deleted!"; puts
      exit 1
    end
  end
  
  def delete_sdl_object_files
    Dir[SDL_PRI_BUILD_PATH + "/*"].each do |file|
      if((not file == '.gitignore') && (not file == '.svn'))
        colour_puts :output, "deleting #{file}"
        File.delete(file)
      end
    end
    if(Dir.entries(SDL_PRI_BUILD_PATH) == ['.','..','.gitignore','.svn'] ||
       Dir.entries(SDL_PRI_BUILD_PATH) == ['.','..'] ||
       Dir.entries(SDL_PRI_BUILD_PATH) == ['.','..','.gitignore'] ||
       Dir.entries(SDL_PRI_BUILD_PATH) == ['.','..','.svn'])
      puts; colour_puts :success, "verified old pri sdl object files deleted!"; puts
    else
      3.times{puts}; colour_puts :failure, "ERROR! Couldn't verify old sdl pri object files deleted!"; puts
      exit 1
    end
    Dir[SDL_SEC_BUILD_PATH + "/*"].each do |file|
      if((not file == '.gitignore') && (not file == '.svn'))
        colour_puts :output, "deleting #{file}"
        File.delete(file)
      end
    end
    if(Dir.entries(SDL_SEC_BUILD_PATH) == ['.','..','.gitignore','.svn'] ||
       Dir.entries(SDL_SEC_BUILD_PATH) == ['.','..'] ||
       Dir.entries(SDL_SEC_BUILD_PATH) == ['.','..','.gitignore'] ||
       Dir.entries(SDL_SEC_BUILD_PATH) == ['.','..','.svn'])
      puts; colour_puts :success, "verified old sec sdl object files deleted!"; puts
    else
      3.times{puts}; colour_puts :failure, "ERROR! Couldn't verify old sdl sec object files deleted!"; puts
      exit 1
    end
  end
  
  def assemble assembler, src, obj, processor
    colour_puts(:narrative, "assembling #{File.basename(src)} (#{$build_type})..")
    msg = "#{assembler} /q /p#{processor} #{src.gsub('/','\\')} /o#{obj.gsub('/','\\')}"
    execute msg
    colour_puts(:output, msg)
    if check_file_exists(BUILD_FDL_PATH, src.downcase.gsub('.asm','.o'))
      colour_puts(:success, "#{File.basename(src).downcase.gsub('.asm','.o')} created")
    else
      3.times{puts}; colour_puts(:failure, "ERROR! #{File.basename(src)} assembly failed!")
      exit 1
    end
    puts
  end

  def compile compiler,src, obj, processor, defines, source_paths, optimization
    colour_puts(:narrative, "compiling #{File.basename(src.gsub('/','\\'))} (#{$build_type})...")
    msg = "#{compiler.gsub('/','\\')} -d#{defines} -p=#{processor} -I#{source_paths.join(' -I')} #{src.gsub('/','\\')} -o #{obj.gsub('/','\\')} #{optimization}"
    execute msg
    colour_puts(:output, msg)
    if check_file_exists(BUILD_FDL_PATH, src.downcase.gsub('.c','.o'))
      colour_puts(:success, "#{File.basename(src).downcase.gsub('.c','.o')} created")
    else
      3.times{puts}; colour_puts(:failure, "ERROR! #{File.basename(src)} compilation failed!")
      exit 1
    end
    puts
  end


  def gcc_compile src, obj, includes, parameters, type, build_path
    colour_puts(:narrative, "compiling #{File.basename(src.gsub('/','\\'))} (#{type})...")
    #~ puts "Compiling #{src}..."
    msg = "#{UNIT_TEST_COMPILER} -c -I#{includes.join(' -I')}  -D#{parameters.join(' -D')} #{src} -o #{obj}"
    execute msg
    colour_puts(:output, msg)
    if check_file_exists(build_path, src.downcase.gsub('.c','.o'))
      colour_puts(:success, "#{File.basename(src).downcase.gsub('.c','.o')} created")
    else
      3.times{puts}; colour_puts(:failure, "ERROR! #{File.basename(src)} compilation failed!")
      exit 1
    end
    puts
  end
  
  def check_file_exists location, file
    File.exist? "#{location}\\#{File.basename(file).downcase}".gsub('\\','/')
  end
  
  def collect_object_files 
    obj_files = ""
    Dir[BUILD_FDL_PATH + '/*' + OBJ_EXTENSION].each do |file|
      obj_files += "#{file.gsub('/','\\')} "
    end
    if obj_files == ""
      3.times{puts}; colour_puts(:failure, "ERROR! No object files!")
      exit 1  
    end
    obj_files
  end
  
  def link linker, executable, linkerfile, link_paths, libraries
    puts ; colour_puts(:narrative,  "Linking object files (#{$build_type})..."); puts
    msg = "#{linker} /w /x #{link_paths} #{linkerfile} #{collect_object_files} #{libraries} /o #{executable}"
    colour_puts(:output, msg); puts
    execute msg; puts
    if check_file_exists(BUILD_OUT_PATH,$build_type + BIN_EXTENSION)
      colour_puts(:success, "#{BUILD_OUT_PATH}\\#{$build_type + BIN_EXTENSION} created")
    else
      3.times{puts}; colour_puts(:failure, "ERROR! #{$build_type + BIN_EXTENSION} failed to link!")
      exit 1
    end
    puts
  end

  def gcc_link prerequisites, switches, executable
    puts ; colour_puts(:narrative,  "Linking object files (#{File.basename(executable)})..."); puts
    msg = "#{UNIT_TEST_LINKER} #{switches} #{prerequisites.join(' ')} -o #{executable}"
    colour_puts(:output, msg); puts
    execute msg; puts
    #    if check_file_exists(UNIT_TEST_BUILD_PATH, 'unit_test' + BIN_EXTENSION)
    #      colour_puts(:success, "#{UNIT_TEST_BUILD_PATH}\\#{'unit_test' + BIN_EXTENSION} created")
    #    else
    #      3.times{puts}; colour_puts(:failure, "ERROR! #{'unit_test' + BIN_EXTENSION} failed to link!")
    #      exit 1
    #    end
    puts
    
  end
  
  def build_hex(converter, build, file_type)
    case file_type
    when :fdl_upload
      puts; colour_puts(:narrative, "generating #{build} FDL UPLOAD (hex) (#{$build_type})...");  puts
      programming_range = PRI_FDL_UPLOAD_CODE_RANGE
    when :presto_upload
      puts; colour_puts(:narrative, "generating #{build} PRESTO UPLOAD (hex) (#{$build_type})...");  puts
      programming_range = PRI_PRESTO_UPLOAD_CODE_RANGE
    else
      3.times{puts}; colour_puts(:failure, "ERROR! unknown file_type in build_hex!")
      exit 1  
    end
    msg = "#{converter} /a INHX32 /r #{programming_range} /q #{BUILD_OUT_PATH.gsub('/','\\')}\\#{build}.cof"
    colour_puts :output, msg
    execute msg
    File.rename("#{BUILD_OUT_PATH}\\#{build}.hex",
                "#{BUILD_OUT_PATH}\\#{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.hex") 
    if check_file_exists(BUILD_OUT_PATH, "#{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.hex")
      colour_puts(:success, "#{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.hex created")
    else
      3.times{puts}; colour_puts(:failure, "ERROR! #{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.hex conversion failed!")
      exit 1
    end
    puts
  end
  
  def build_fdl(build,file_type)
    puts; colour_puts(:narrative, "generating #{build} FDL UPLOAD (fdl) (#{$build_type})...");  puts
    msg = "#{BUILD_PATH}\\HexConverter #{BUILD_OUT_PATH.gsub('/','\\')}\\#{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.hex"
    colour_puts(:output, msg)
    execute msg
    if check_file_exists(BUILD_OUT_PATH, "\\#{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.fdl")
      colour_puts(:success, "#{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.fdl created")
    else
      3.times{puts}; colour_puts(:failure, "ERROR! #{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.fdl conversion failed!")
      exit 1
    end
    puts
  end

  def cleanup_out_files(build)
    File.delete("#{BUILD_OUT_PATH}\\#{build}.cof")
    File.delete("#{BUILD_OUT_PATH}\\#{build}.lst")
    File.delete("#{BUILD_OUT_PATH}\\#{build}.cod")
  end
  
  def run_test executable      
    execute "\"#{executable}\""
  end
  
  #  write_result_file(exe_file, run_test(exe_file))
  
  def write_result_file filename, results
    begin
      my_results = results.split("\n")
      my_results.each do |line|
        if line =~ /PASS$/
          colour_puts(:success, line)
        elsif line =~ /IGNORED$/
          colour_puts(:yellow, line)
        elsif line.include?('Tests') &&
            line.include?('Failures') &&
            line.include?('Ignored')
          puts
          colour_print(:success, line[0..line.index('Tests') + 5 ])
          if line.include?('0 Failures')
            colour_print(:success, line[line.index('Tests') + 6 .. line.index('Failures') + 8 ])
          else
            colour_print(:failure, line[line.index('Tests') + 6 .. line.index('Failures') + 8 ])
          end

          if line.include?('0 Ignored')
            colour_puts(:green, line[line.index('Failures') + 9 .. -1])
          else
            colour_puts(:yellow, line[line.index('Failures') + 9 .. -1])
          end
          puts
        elsif line =~ /^OK$/
          colour_puts(:success, line)
        else
          colour_puts(:failure, line)
        end
      end
    rescue
    end
    if (results.include?("OK\n"))
      output_file = filename.gsub(BIN_EXTENSION, '.testpass')
    else
      output_file = filename.gsub(BIN_EXTENSION, '.testfail')
    end
    File.open(output_file, 'w') do |f|
      f.print results
    end
  end
  
  private #####################

  def execute command_string
    #~ report command_string
    output = `#{command_string}`
    if not $task == :run_unit_tests      
      report output
    end
    output
  end
end
