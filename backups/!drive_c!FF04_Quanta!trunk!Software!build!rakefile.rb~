
ROOT_DIR = File.expand_path(File.join(File.dirname(__FILE__),'..'))

require File.join(ROOT_DIR,'build','rake','rakefile_helper')

# require File.join(ROOT_DIR,'build','mcp_parser')
# require File.join(ROOT_DIR,'pri','bin','unit_test','auto','unity_test_summary')
# require File.join(ROOT_DIR,'pri','bin','unit_test','auto','generate_test_runner')
# require File.join(ROOT_DIR,'pri','bin','unit_test','generate_state_tests_from_state_machine_routines.rb')
# require File.join(ROOT_DIR,'pri','bin','unit_test','generate_state_tests.rb')
# require File.join(ROOT_DIR,'pri','bin','unit_test','generate_state_tests.rb')
# require File.join(ROOT_DIR,'ter','state_machine','lib','generate_state_machine.inc.rb')

require 'spec/rake/spectask'

include RakefileHelpers

namespace :generate do
  desc "generate state machine - usage rake generate:state_machine state_name=main"
  task :state_machine do
    require File.join(ROOT_DIR,'build','rake','generate_state_machine')
    p "state machine name is #{ENV['state_name']}"
  end
end

desc 'create state machine generation structure (name of state machine passed in)'
task :create_state_machine => [:name] do |n|
  puts n
end

desc "create_database.yml"
task :create_database_yml do
  unless File.exists? File.join("config", "database.yml")
    puts "Where's your database.yml, dude?"
    if File.exist? File.join("config", "database.yml.example")
      puts "(elided)... so I'll make a copy of it for you."

      cp File.join("config", "database.yml.example"),
        File.join("config", "database.yml")

        abort "(elided)...rerun the last command."
    else
      abort "(elided)...There's no config/database.yml.example..."
    end
  end
end


# desc "Build and generate all downloadable fdl and presto output files"
# task :default => [:check_tool_versions,
#                   :base_tft,
#                   :base_cstn,
#                   :factory,
#                   :sec_tft,
#                   :sec_cstn,
#                   :sec_factory,
#                   :tertiary,
# 									:sim,
#                   :unit_tests,
#                   :summary]

# desc "Build and generate base_tft downloadable fdl file and presto"
# task :base_tft => [:check_tool_versions,
#                    :build_base_tft]

# desc "Build and generate base_cstn downloadable fdl file and presto."
# task :base_cstn => [:check_tool_versions,
#                     :build_base_cstn]

# desc "Build and generate secondary (tft) downloadable fdl file and presto."
# task :sec_tft => [:check_tool_versions,
#                     :build_sec_tft]

# desc "Build and generate secondary (cstn) downloadable fdl file and presto."
# task :sec_cstn => [:check_tool_versions,
#                     :build_sec_cstn]

# desc "Build and generate factory downloadable fdl file and presto."
# task :factory => [:check_tool_versions,
#                   :build_factory]

# desc "Build and generate secondary factory downloadable fdl file and presto."
# task :sec_factory => [:check_tool_versions,
#                     :build_sec_factory]

# desc "Build tertiary state-machine code."
# task :build_tertiary_state_machine_code => [:tertiary_spec,
# 																															:build_ter_state_code]

# desc "Build and generate tertiary hex and fdl file."
# task :tertiary => [:check_tool_versions,
# 													:build_tertiary_state_machine_code, 
# 													:build_tertiary]

# desc "Build and run unit tests"
# task :unit_tests => [:clean_unit_tests,
# 											:generate_state_tests ,
# 											:run_unit_tests,
# 											:unit_test_summary]

# desc "Build simulation code"
# task :sim => [:build_sim]

# desc "Parse State Val table and StateMachine and generate state val tests" 
# task :generate_state_tests => [:generate_state_tests_1,
# 																						:generate_state_tests_2]

#PRIMARY_TFT_LINKER_FILE = File.join(ROOT_PATH,'pri','lib','base','18F8720.LKR').gsub('/','\\')
#PRIMARY_CSTN_LINKER_FILE = File.join(ROOT_PATH,'pri','lib','base','18F8720.LKR').gsub('/','\\')
#PRIMARY_FACTORY_LINKER_FILE = File.join(ROOT_PATH,'pri','lib','factory','18F8720.LKR').gsub('/','\\')
#SEC_FACTORY_LINKER_FILE = File.join(ROOT_PATH,'sec','lib','factory','18F2520.LKR').gsub('/','\\')

# task :check_tool_versions do
#   colour_puts(:narrative, "checking tool versions...")
#   check_tool_versions
#   $assembler = "#{$build_tool[:assembler][:path]}#{$build_tool[:assembler][:name]}"
#   $compiler = "#{$build_tool[:compiler][:path]}#{$build_tool[:compiler][:name]}"
#   $linker = "#{$build_tool[:linker][:path]}#{$build_tool[:linker][:name]}"  
#   $mp2hex = "#{$build_tool[:mp2hex][:path]}#{$build_tool[:mp2hex][:name]}"


# Spec::Rake::SpecTask.new(:tertiary_spec) do |t|
#   t.spec_files = File.join(ROOT_DIR,'ter','state_machine','spec','spec_test.rb')
#     #~ t.warning = true
#     t.rcov = true
# 		t.spec_opts = [ '--format','html:spec_output.html',
# 													'--format','nested:spec_output.doc',
# 													'--format','progress'
# 												]
# end

# task :build_ter_state_code do
#   colour_puts(:narrative,"Building Tertiary StateMachine Code...")
# 	GenerateASM.new.state_machine_inc
# 	GenerateASM.new.state_table_asm
# 	GenerateASM.new.state_validation_table_asm
# end

# task :build_base_tft do
#   $source_paths = PRIMARY_TFT_SOURCE_PATHS
#   $processor = PRIMARY_PROCESSOR
#   $build_type = TFT_BUILD_TYPE
#   $defines = PRIMARY_DEFINES
#   $linker_script = PRIMARY_TFT_LINKER_FILE
#   $bin_path = File.join(PRI_BIN_DIR, $build_type)
# 	$lib_path = PRIMARY_LIB_PATH
#   $libraries = PRIMARY_LIBRARIES
# 	$optimisation = PRIMARY_OPTIMIZATION
#   build
# end

# task :build_base_cstn do
#   $source_paths = PRIMARY_CSTN_SOURCE_PATHS
#   $processor = PRIMARY_PROCESSOR
#   $build_type = CSTN_BUILD_TYPE
#   $defines = "#{PRIMARY_DEFINES} -dUSE_CSTN_DISPLAY"
#   $linker_script = PRIMARY_TFT_LINKER_FILE
#   $bin_path = File.join(PRI_BIN_DIR, $build_type)
# 	$lib_path = PRIMARY_LIB_PATH
#   $libraries = PRIMARY_LIBRARIES
# 	$optimisation = PRIMARY_OPTIMIZATION
#   build
# end  

# task :build_sec_tft do
#   $source_paths = SECONDARY_SOURCE_PATHS
#   $processor = SECONDARY_PROCESSOR
#   $build_type = SEC_TFT_BUILD_TYPE
#   $defines = SEC_TFT_DEFINES
#   $linker_script = SECONDARY_LINKER_FILE
#   $bin_path = File.join(SEC_TFT_BIN_DIR)
# 	$lib_path = SECONDARY_LIB_PATH
#   $libraries = SECONDARY_LIBRARIES
# 	$optimisation = SECONDARY_OPTIMIZATION
#   build 
# end

# task :build_sec_cstn do
#   $source_paths = SECONDARY_SOURCE_PATHS
#   $processor = SECONDARY_PROCESSOR
#   $build_type = SEC_CSTN_BUILD_TYPE
#   $defines = SEC_CSTN_DEFINES
#   $linker_script = SECONDARY_LINKER_FILE
#   $bin_path = File.join(SEC_CSTN_BIN_DIR)
# 	$lib_path = SECONDARY_LIB_PATH
#   $libraries = SECONDARY_LIBRARIES
# 	$optimisation = SECONDARY_OPTIMIZATION
#   build 
# end

# task :build_factory do
#   $source_paths = PRIMARY_FACTORY_SOURCE_PATHS
#   $processor = PRIMARY_PROCESSOR
#   $build_type = FACTORY_BUILD_TYPE
#   $defines = PRIMARY_DEFINES
#   $linker_script = PRIMARY_FACTORY_LINKER_FILE
#   $bin_path = File.join(PRI_BIN_DIR, $build_type)
# 	$lib_path = PRIMARY_LIB_PATH
#   $libraries = PRIMARY_LIBRARIES
# 	$optimisation = PRIMARY_OPTIMIZATION
#   build
# end

# task :build_sec_factory do
#   $source_paths = SEC_FACTORY_SOURCE_PATHS
#   $processor = SECONDARY_PROCESSOR
#   $build_type = SEC_FACTORY_BUILD_TYPE
#   $defines = SEC_FACTORY_DEFINES
#   $linker_script = SEC_FACTORY_LINKER_FILE
#   $bin_path = File.join(SEC_FACTORY_BIN_DIR)
# 	$lib_path = SECONDARY_LIB_PATH
#   $libraries = SECONDARY_LIBRARIES
# 	$optimisation = SECONDARY_OPTIMIZATION
#   build 
# end

# task :build_tertiary do
#   $source_paths = TERTIARY_SOURCE_PATHS
#   $processor = TERTIARY_PROCESSOR
#   $build_type = TERTIARY_BUILD_TYPE
#   $linker_script = TERTIARY_LINKER_FILE
#   $bin_path = File.join(TERTIARY_BIN_DIR)
#   build 
# end

# task :clean_unit_tests do
# 	  Dir[File.join(ROOT_DIR,'pri','bin','unit_test', 'build') + "/*"].each do |file|
# 			if not file == '.gitignore'
# 				colour_puts :output, "deleting #{file}"
# 				File.delete(file)
# 			end
#     end
# end

# task :generate_state_tests_1 do
#   colour_puts :narrative, "generating state tests..."
# 	@state_routes = GenerateStateTests.
# 													new.
# 													load_states_from_state_val_table
# 	@states = []												
# 	@state_routes.each_key do |k|
# 		@states.push k
# 	end
# 	@states.uniq!
# 	WriteStateTests.
# 	new.
# 	write_file(@state_routes)
# end

# task :generate_state_tests_2 do
#   colour_puts :narrative, "generating state tests from stateMachineRoutines..."
# 	@state_routes = GenerateStateTestsFromStateMachineRoutines.
# 													new.
# 													load_states_from_stateMachineRoutines
#  @states.uniq!
# 	WriteStateTestsFromStateMachineRoutines.
# 	new.
# 	write_file(@state_routes)
# end	

# task :build_documentation do
# 	require File.expand_path(File.join(File.dirname(__FILE__),'..','docs','lib','build_docs'))
# end

desc "Format all C code to WhiteSmith style"
task :format_code do
  system(
         "astyle/bin/AStyle.exe #{File.join(ROOT_DIR,'*.c')} --style=whitesmith --indent=spaces=2 --recursive --verbose --convert-tabs  --unpad-paren --pad-oper")
end

# def build
#   #  loop do
#   #display_version
#   puts
#   colour_puts(:narrative,"building Code...")
#   puts ""
#   delete_object_files
#   build_code
# end

# # builds simulation
# task :build_sim do
#   colour_puts(:narrative, "building simulation")
#   puts
#   delete_sdl_object_files
#   #compile pri SDL files
#   SIM_PRI_SOURCE_PATHS.each do |path|
#     Dir[path + '/*.c'].each do |file|
#       gcc_compile(file,
# 			SDL_PRI_BUILD_PATH + '/' + File.basename(file).gsub('.c', OBJ_EXTENSION),
# 			SIM_PRI_SOURCE_PATHS,
# 			%w{TEST SDL_SIMULATION}, 
# 			'pri sim',
# 			SDL_PRI_BUILD_PATH)
#     end
#   end
  
#   #compile sec SDL files
#   SIM_SEC_SOURCE_PATHS.each do |path|
#     Dir[path + '/*.c'].each do |file|
#       gcc_compile(file,
# 			SDL_SEC_BUILD_PATH + '/' + File.basename(file).gsub('.c', OBJ_EXTENSION),
# 			SIM_SEC_SOURCE_PATHS ,
# 			%w{TEST SDL_SIMULATION}, 
# 			'sec sim',
# 			SDL_SEC_BUILD_PATH)
#     end
#   end
  
#   #compile SDL files
# 		SIM_SDL_SOURCE_PATHS.each do |path|
#     Dir[path + '/*.c'].each do |file|
# 			gcc_compile(file, 
# 			SDL_PRI_BUILD_PATH + '/' + File.basename(file).gsub('.c', OBJ_EXTENSION),
# 			SIM_PRI_SOURCE_PATHS ,
# 			%w{TEST SDL_SIMULATION}, 
# 			'sdl sim',
# 			SDL_PRI_BUILD_PATH)
# 		end
#   end
	
#   obj_files = []
#   Dir[SDL_PRI_BUILD_PATH+"/*#{OBJ_EXTENSION}"].each do |file|
#     local_file = File.basename(file).gsub(OBJ_EXTENSION,"#{OBJ_EXTENSION} ")
#     obj_files << SDL_PRI_BUILD_PATH + '/' + local_file
#   end
#   Dir[SDL_SEC_BUILD_PATH+"/*#{OBJ_EXTENSION}"].each do |file|
#     local_file = File.basename(file).gsub(OBJ_EXTENSION,"#{OBJ_EXTENSION} ")
#     obj_files << SDL_SEC_BUILD_PATH + '/' + local_file
#   end
	
#     #~ Dir[SECONDARY_BUILD_PATH+"/*#{OBJ_EXTENSION}"].each do |file|
#     #~ local_file = File.basename(file).gsub(OBJ_EXTENSION,"#{OBJ_EXTENSION} ")
#     #~ run_file += SECONDARY_BUILD_PATH+'/'+local_file
#   #~ end
#   gcc_link(obj_files, '-DTEST -DSDL_SIMULATION', '../testing/SDLtest/sdl.exe -lmingw32 -lSDLmain -lSDL -lSDL_image -lSDL_ttf')
# end

# # builds and runs all the unit tests
# task :run_unit_tests do
#   $task = :run_unit_tests  
#   colour_puts(:narrative, "Starting Test Suite")
#   puts
# 	delete_object_files
#   runner_generator = UnityTestRunnerGenerator.new
#   test_sets = {}
  
#   #compile unity files
#   Dir[UNITY_PATH + '/*.c'].each do |file|
# 			gcc_compile(file, 
# 			UNIT_TEST_BUILD_PATH + '/' + File.basename(file).gsub('.c', OBJ_EXTENSION),
# 			UNIT_TEST_SOURCE_PATHS,
# 			%w{TEST} ,
# 			'unit tests',
# 			UNIT_TEST_BUILD_PATH)
#   end
  
#   #compile source files
#   UNIT_TEST_SOURCE_PATHS.each do |path|
#     Dir[path +'/*.c'].each do |file|
#       gcc_compile(file,
#                         UNIT_TEST_BUILD_PATH + '/' + File.basename(file).gsub('.c', OBJ_EXTENSION), 
# 												UNIT_TEST_SOURCE_PATHS,%w{TEST} , 
# 												'unit tests',
# 												UNIT_TEST_BUILD_PATH)
#     end 
#   end
  
#   #compile test files
#   Dir[UNIT_TEST_PATH + '/*.c'].each do |file|
#     gcc_compile(file,
# 				UNIT_TEST_BUILD_PATH + '/' + File.basename(file).gsub('.c', OBJ_EXTENSION),
# 				UNIT_TEST_SOURCE_PATHS,%w{TEST} , 
# 				'unit tests',
# 				UNIT_TEST_BUILD_PATH)
#   end
  
#   #compile runner files
#   Dir[UNIT_TEST_PATH+'/*.c'].each do |file|
#     run_file =  UNIT_TEST_BUILD_PATH + '/' + File.basename(file).gsub('.c','_Runner.c')
#     test_set = runner_generator.run(file, run_file)
#     gcc_compile(run_file, 
# 				run_file.gsub('.c', OBJ_EXTENSION),
# 				UNIT_TEST_SOURCE_PATHS,
# 				%w{TEST},  
# 				'unit tests',
# 				UNIT_TEST_BUILD_PATH)
#     test_sets[run_file.gsub('_Runner.c', BIN_EXTENSION)] = test_set.map {|req_file| UNIT_TEST_BUILD_PATH + '/' + File.basename(req_file).gsub(/\.[c|h]/, OBJ_EXTENSION)}
#   end
  
#   #link and run each test
#   test_sets.each_pair do |exe_file, obj_files|
#     colour_puts(:narrative, "\n.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .");puts
#     flush_output
#     gcc_link(obj_files,'-DTEST', exe_file)
#     write_result_file(exe_file, run_test(exe_file))
#   end
# end

# #This runs our unit_test summary
# task :unit_test_summary do
#   flush_output
#   summary = UnityTestSummary.new
#   summary.set_root_path($here)
#   summary.set_targets(Dir[UNIT_TEST_BUILD_PATH + '/*.test*'])
#   summary.run
# end

# #This runs our test summary
# task :summary do        
#   flush_output        
#   colour_puts(:success,"Build Finished!")
# end                     

# def build_code
#   source_files = McpParser.extract_source(File.join($bin_path,"#{$build_type}.mcp"))
#   source_files.each do |file|
#     if file =~ /\.c$/i
#       compile($compiler,
#               File.expand_path(File.join($bin_path,file)),
#               '-fo=' + BUILD_FDL_PATH + '/' + File.basename(file).downcase.gsub('.c', OBJ_EXTENSION),
#               $processor,
#               $defines,
#               $source_paths,
# 							$optimisation)
#     elsif file =~ /.asm$/i
#       assemble($assembler,
#                File.expand_path(File.join($bin_path,file)),
#                File.expand_path(BUILD_FDL_PATH + '/' + File.basename(file).downcase.gsub('.asm', OBJ_EXTENSION)),
#                $processor)
#     end	
#   end

#   link($linker,
#        File.join(BUILD_OUT_PATH,$build_type + BIN_EXTENSION),
#        $linker_script,
#        $lib_path,
#        $libraries)
  
#   build_hex($mp2hex,
#             $build_type,
#             :fdl_upload)
#   build_fdl($build_type,:fdl_upload)
#   build_hex($mp2hex,
#             $build_type, :presto_upload)
# end


