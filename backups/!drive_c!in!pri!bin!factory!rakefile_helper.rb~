module RakefileConstants  
  ROOT_PATH = File.expand_path(File.join(File.dirname(__FILE__),'..','..','..'))
  DOCS_LIB_PATH = File.join(ROOT_PATH,'docs','lib')
  require File.join(ROOT_PATH,'build','colour_prompt')
  require File.join(DOCS_LIB_PATH,'get_time_date.rb')
  require File.join(DOCS_LIB_PATH,'version.rb')
  require File.join(ROOT_PATH,'build','check_version')

  BUILD_TYPE = 'base_tft'
  C_EXTENSION = '.c'
  OBJ_EXTENSION = '.o'
  BIN_EXTENSION = '.cof'
  PRI_BIN_DIR = File.join(ROOT_PATH,'pri','bin')
  BUILD_FDL_PATH = File.join(PRI_BIN_DIR,BUILD_TYPE, 'buildfdls')
  HEX_CONVERTER_PATH = File.join(ROOT_PATH,'build')
  
  PRIMARY_PROCESSOR = '18F8720'
  PRIMARY_DEFINES = '_FINAL=2'
  PRIMARY_TFT_SOURCE_PATHS = %w'../../lib/base ../../lib/common ../../lib/debug ../../lib/tft'
  PRIMARY_TFT_LINKER_FILE = File.join(ROOT_PATH,'pri','lib','base','18F8720.LKR').gsub('/','\\')
  PRIMARY_LIBRARIES ='p18f8720.lib clib.lib'
  PRIMARY_LIB_PATH ="/l#{File.join(ROOT_PATH,'pri','lib','lib')}"
  PRIMARY_OPTIMIZATION ='-scs -mL -pa=4'
  PRI_OUTPUT_FILE = 'PriBase'
  PRI_FDL_UPLOAD_CODE_RANGE = '0x0000-0x1FCFF'
  PRI_PRESTO_UPLOAD_CODE_RANGE = '0x0000-0x30000D'
  PRI_OUT_PATH = File.join(PRI_BIN_DIR,BUILD_TYPE,'out')
  SECONDARY_PROCESSOR = '18F2520'
  SECONDARY_DEFINES = '_FINAL=2'
  SECONDARY_SOURCE_PATHS = %w'../../../sec'
  SECONDARY_LINKER_FILE = File.join(ROOT_PATH,'sec','18F2520.LKR').gsub('/','\\')
  SECONDARY_LIBRARIES = 'p18f2520.lib clib.lib'
  SECONDARY_OPTIMIZATION ='-mL -pa=5'
  SECONDARY_LIB_PATH = "/l #{File.join(ROOT_PATH,'sec')}"
  SEC_OUTPUT_FILE = 'SecBase'
end

module RakefileHelpers
  include RakefileConstants
  $version = Version.new.get_version
  $build_time = GetTimeDate.read
  $formatted_build_time = $build_time.gsub(' ','_').gsub(',','_').gsub(':','_').downcase
  
  def colour_write(type, role, str)
    @colour = ColourCommandLine.new
    case role
    when :narrative
      clr = :dark_yellow 
    when :output
      clr = :dark_cyan
    when :success
      clr = :green
    when :failure
      clr = :red
    else
      clr = role
    end
    type == :puts ? @colour.puts_c(clr, str): @colour.print_c(clr, str)
    @colour = nil
  end
  
  def colour_puts(role,str)
    colour_write(:puts,role,str)
  end
  
  def colour_print(role,str)
    colour_write(:print,role,str)
  end

  def flush_output
    $stderr.flush
    $stdout.flush
  end
  
  def report message
    puts message
    flush_output
  end

  $build_tool = nil
  
  def check_tool_versions
    $build_tool = ToolVersions.new.fetch_build_tool_info
    puts 
    colour_print(:narrative,"compiler =>  #{$build_tool[:compiler][:name]}")
    colour_print(:output,"  #{$build_tool[:compiler][:version]}")
    colour_puts(:success, " found");puts
    colour_print(:narrative,"assembler => #{$build_tool[:assembler][:name]}")
    colour_print(:output,"  #{$build_tool[:assembler][:version]}")
    colour_puts(:success, " found");puts
    colour_print(:narrative,"linker => #{$build_tool[:linker][:name]}")
    colour_print(:output,"  #{$build_tool[:linker][:version]}")
    colour_puts(:success, " found");puts
    colour_print(:narrative,"hex builder => #{$build_tool[:mp2hex][:name]}")
    colour_print(:output,"  #{$build_tool[:mp2hex][:version]}")
    colour_puts(:success, " found");puts
    colour_print(:narrative, "toolChain path is ")
    colour_puts(:success, "  #{$build_tool[:path][:path]}");puts
    colour_print(:narrative,"library path is ")
    colour_puts(:success,"  #{$build_tool[:library][:path]}");puts
    sleep 2
  end
  
  def delete_object_files
    colour_puts(:narrative, "deleting object files...")
    Dir[BUILD_FDL_PATH + "/*"].each do |file|
      colour_puts :output, "deleting #{file}"
      File.delete(file)
    end
    if Dir[BUILD_FDL_PATH + "/*"].empty?
      puts; colour_puts :success, "verified old object files deleted!"; puts
    else
      3.times{puts}; colour_puts :failure, "ERROR! Couldn't verify old object files deleted!"; puts
      exit 1
    end
  end
  
  def assemble src, obj, processor
    colour_print(:narrative, "assembling #{File.basename(src)}...")
    msg = "#{ASSEMBLER} /q /p#{processor} #{src} /o#{obj}"
    execute msg
    colour_puts(:output, msg)
    if check_object_file_exists(src, '.asm')
      colour_puts(:success, "#{File.basename(src).downcase.gsub('.asm','.o')} created")
    else
      3.times{puts}; colour_puts(:failure, "ERROR! #{File.basename(src)} assembly failed!")
      exit 1
    end
    puts
  end

  def compile src, obj, processor, defines, source_paths, optimization
    colour_print(:narrative, "compiling #{File.basename(src)}...")
    msg = "#{COMPILER} -d#{defines} -p=#{processor} -I#{source_paths.join(' -I')} #{src} -o #{obj} #{optimization}"
    execute msg
    colour_puts(:output, msg)
    if true#check_object_file_exists(src, '.c')
      colour_puts(:success, "#{File.basename(src).downcase.gsub('.c','.o')} created")
    else
      3.times{puts}; colour_puts(:failure, "ERROR! #{File.basename(src)} compilation failed!")
      exit 1
    end
    puts
  end
  
  def check_object_file_exists obj, extension
    return File.exist?("#{BUILD_FDL_PATH}\\#{File.basename(obj).downcase.gsub(extension,'.o')}")
  end
  
  def collect_object_files 
    obj_files = ""
    Dir[BUILD_FDL_PATH + '/*' + OBJ_EXTENSION].each do |file|
      obj_files += "#{file.gsub('/','\\')} "
    end
    if obj_files == ""
      3.times{puts}; colour_puts(:failure, "ERROR! No object files!")
      exit 1  
    end
    obj_files
  end
  
  def link executable, linkerfile, link_paths, libraries
    puts ; colour_puts(:narrative,  "Linking object files..."); puts
    msg = "#{LINKER} #{link_paths} #{linkerfile} #{collect_object_files} #{libraries} /o #{executable}"
    colour_puts(:output, msg); puts
    execute msg; puts
  end
  
  def build_hex(build, file_type)
    case file_type
    when :fdl_upload
      puts; colour_puts(:narrative, "generating #{build} FDL UPLOAD...");  puts
      programming_range = PRI_FDL_UPLOAD_CODE_RANGE
      when :presto_upload
      puts; colour_puts(:narrative, "generating #{build} PRESTO UPLOAD...");  puts
      programming_range = PRI_PRESTO_UPLOAD_CODE_RANGE
    else
      3.times{puts}; colour_puts(:failure, "ERROR! unknown file_type in build_hex!")
      exit 1  
    end
    msg = "MP2HEX /a INHX32 /r #{programming_range} /q #{PRI_OUT_PATH}\\#{build}.cof"
    colour_puts :output, msg
    execute msg
    File.rename("#{PRI_OUT_PATH}\\#{build}.hex",
                "#{PRI_OUT_PATH}\\#{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.hex") 
  end
  
  def build_fdl(build,file_type)
    msg = "#{HEX_CONVERTER_PATH}\\HexConverter #{PRI_OUT_PATH}\\#{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.hex"
    colour_puts(:output, msg)
    execute msg
  end

  def cleanup_out_files(build)
    File.delete("#{PRI_OUT_PATH}\\#{build}.cof")
    File.delete("#{PRI_OUT_PATH}\\#{build}.lst")
    File.delete("#{PRI_OUT_PATH}\\#{build}.cod")
  end
                
  def generate_output_files_pri()
    puts; colour_puts(:narrative, "generating Primary FDL UPLOAD...");  puts
    msg = "MP2HEX /a INHX32 /r 0x0000-0x1FCFF /q #{BUILD_FDL_PATH}\\#{PRI_OUTPUT_FILE}.cof"
    colour_puts :output, msg
  execute msg
  
  msg = "#{HEX_CONVERTER_PATH}\\HexConverter #{BUILD_FDL_PATH}/#{PRI_OUTPUT_FILE}.hex"
    puts msg
    execute msg
    File.rename("#{PRI_OUT_PATH}\\#{build}_#{file_type.to_s}.fdl",
                "#{PRI_OUT_PATH}\\#{build}_#{file_type.to_s}_#{$version.gsub('.','_')}_#{$formatted_build_time}.fdl")
    
    puts; colour_puts(:narrative, "generating Primary PRESTO UPLOAD...");  puts
    msg = "MP2HEX /a INHX32 /r 0x0000-0x30000D /q #{BUILD_FDL_PATH}\\#{PRI_OUTPUT_FILE}.cof"
    puts msg
    execute msg
end

def generate_output_files_sec()
  puts; colour_puts(:narrative, "generating Secondary FDL UPLOAD..."); puts
  msg = "MP2HEX /a INHX32 /r 0x0000-0x1FCFF /q #{PRI_OUT_PATH}\\#{SEC_OUTPUT_FILE}.cof"
  colour_puts :output, msg
  execute msg
  File.rename("#{PRI_OUT_PATH}\\#{SEC_OUTPUT_FILE}.hex",
              "#{PRI_OUT_PATH}\\#{SEC_OUTPUT_FILE}_fdl_upload_#{$version.gsub('.','_')}_#{$formatted_build_time}.hex")
  msg = "#{HEX_CONVERTER_PATH}\\HexConverter #{PRI_OUT_PATH}\\#{SEC_OUTPUT_FILE}_fdl_upload_#{$version.gsub('.','_')}_#{$formatted_build_time}.hex"
  colour_puts(:output, msg)
  execute msg
    
  puts; colour_puts(:narrative, "generating  Secondary PRESTO UPLOAD"); puts
  msg = "MP2HEX /a INHX32 /r 0x0000-0x30000D /q #{PRI_OUT_PATH}\\#{SEC_OUTPUT_FILE}.cof"
  colour_puts(:output, msg)
  execute msg
  File.rename("#{PRI_OUT_PATH}\\#{SEC_OUTPUT_FILE}.hex",
              "#{PRI_OUT_PATH}\\#{SEC_OUTPUT_FILE}_presto_upload_#{$version.gsub('.','_')}_#{$formatted_build_time}.hex")
end
  
private #####################

  def execute command_string
    #~ report command_string
    output = `#{command_string}`
    report output
    output
  end

end
